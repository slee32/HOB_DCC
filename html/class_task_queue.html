<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HOB_DCC: TaskQueue&lt; dataType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HOBPoster.2018.12.07.2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HOB_DCC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_task_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TaskQueue&lt; dataType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements a queue to transmit data from one RTOS task to another.  
 <a href="class_task_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TaskQueue&lt; dataType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_task_queue.png" usemap="#TaskQueue_3C_20dataType_20_3E_map" alt=""/>
  <map id="TaskQueue_3C_20dataType_20_3E_map" name="TaskQueue_3C_20dataType_20_3E_map">
<area href="class_base_share.html" title="Base class for classes that share data in a thread-safe manner between tasks. " alt="BaseShare" shape="rect" coords="0,0,152,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6eb3342ef8f6413673f1d718c1402385"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a6eb3342ef8f6413673f1d718c1402385">TaskQueue</a> (BaseType_t queue_size, const char *p_name, <a class="el" href="classemstream.html">emstream</a> *=NULL, TickType_t=portMAX_DELAY)</td></tr>
<tr class="memdesc:a6eb3342ef8f6413673f1d718c1402385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a queue object, allocating memory for the buffer.  <a href="#a6eb3342ef8f6413673f1d718c1402385">More...</a><br /></td></tr>
<tr class="separator:a6eb3342ef8f6413673f1d718c1402385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dac62fcf253ab0cf50e47654c5fb29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#ad1dac62fcf253ab0cf50e47654c5fb29">put</a> (const dataType &amp;item)</td></tr>
<tr class="memdesc:ad1dac62fcf253ab0cf50e47654c5fb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the queue behind other items.  <a href="#ad1dac62fcf253ab0cf50e47654c5fb29">More...</a><br /></td></tr>
<tr class="separator:ad1dac62fcf253ab0cf50e47654c5fb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ff464dfa1c2be2beae36fdd9e36b44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a51ff464dfa1c2be2beae36fdd9e36b44">ISR_put</a> (const dataType &amp;item)</td></tr>
<tr class="memdesc:a51ff464dfa1c2be2beae36fdd9e36b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the queue from within an ISR.  <a href="#a51ff464dfa1c2be2beae36fdd9e36b44">More...</a><br /></td></tr>
<tr class="separator:a51ff464dfa1c2be2beae36fdd9e36b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2810b4a2137dd88bc72fd1f20d18eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a7c2810b4a2137dd88bc72fd1f20d18eb">butt_in</a> (const dataType &amp;item)</td></tr>
<tr class="memdesc:a7c2810b4a2137dd88bc72fd1f20d18eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the front of the queue to be retrieved first.  <a href="#a7c2810b4a2137dd88bc72fd1f20d18eb">More...</a><br /></td></tr>
<tr class="separator:a7c2810b4a2137dd88bc72fd1f20d18eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d85ebdbee24d455f97b37a018f0230"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#aa3d85ebdbee24d455f97b37a018f0230">ISR_butt_in</a> (const dataType &amp;item)</td></tr>
<tr class="memdesc:aa3d85ebdbee24d455f97b37a018f0230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the front of the queue from within an ISR.  <a href="#aa3d85ebdbee24d455f97b37a018f0230">More...</a><br /></td></tr>
<tr class="separator:aa3d85ebdbee24d455f97b37a018f0230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c1d8b98bcb89d77919ad9ce69320a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a29c1d8b98bcb89d77919ad9ce69320a1">is_empty</a> (void)</td></tr>
<tr class="memdesc:a29c1d8b98bcb89d77919ad9ce69320a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue is empty.  <a href="#a29c1d8b98bcb89d77919ad9ce69320a1">More...</a><br /></td></tr>
<tr class="separator:a29c1d8b98bcb89d77919ad9ce69320a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15630b93ea2a6428aff8234213fac24f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a15630b93ea2a6428aff8234213fac24f">ISR_is_empty</a> (void)</td></tr>
<tr class="memdesc:a15630b93ea2a6428aff8234213fac24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue is empty, from within an ISR.  <a href="#a15630b93ea2a6428aff8234213fac24f">More...</a><br /></td></tr>
<tr class="separator:a15630b93ea2a6428aff8234213fac24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b696b7e87f4e1bb5cfde83f91dcef75"><td class="memItemLeft" align="right" valign="top">dataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a8b696b7e87f4e1bb5cfde83f91dcef75">get</a> (void)</td></tr>
<tr class="memdesc:a8b696b7e87f4e1bb5cfde83f91dcef75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return and remove the item at the head of the queue.  <a href="#a8b696b7e87f4e1bb5cfde83f91dcef75">More...</a><br /></td></tr>
<tr class="separator:a8b696b7e87f4e1bb5cfde83f91dcef75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f0fd2a291dacf66983942b82e2997b"><td class="memItemLeft" align="right" valign="top">dataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a57f0fd2a291dacf66983942b82e2997b">ISR_get</a> (void)</td></tr>
<tr class="memdesc:a57f0fd2a291dacf66983942b82e2997b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return and remove the item at the head of the queue from within an ISR.  <a href="#a57f0fd2a291dacf66983942b82e2997b">More...</a><br /></td></tr>
<tr class="separator:a57f0fd2a291dacf66983942b82e2997b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696a695c31e089cf2361f8a16c2fefe6"><td class="memItemLeft" align="right" valign="top">dataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a696a695c31e089cf2361f8a16c2fefe6">look_at</a> (void)</td></tr>
<tr class="memdesc:a696a695c31e089cf2361f8a16c2fefe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the item at the queue head without removing it.  <a href="#a696a695c31e089cf2361f8a16c2fefe6">More...</a><br /></td></tr>
<tr class="separator:a696a695c31e089cf2361f8a16c2fefe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f13cf022edebc95b8c9ca36814a820b"><td class="memItemLeft" align="right" valign="top">dataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a5f13cf022edebc95b8c9ca36814a820b">ISR_look_at</a> (void)</td></tr>
<tr class="memdesc:a5f13cf022edebc95b8c9ca36814a820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the item at the front of the queue without deleting it, from within an ISR.  <a href="#a5f13cf022edebc95b8c9ca36814a820b">More...</a><br /></td></tr>
<tr class="separator:a5f13cf022edebc95b8c9ca36814a820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c24c84baac830cce4d6f528a0eee23c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a0c24c84baac830cce4d6f528a0eee23c">not_empty</a> (void)</td></tr>
<tr class="memdesc:a0c24c84baac830cce4d6f528a0eee23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue has contents which can be read.  <a href="#a0c24c84baac830cce4d6f528a0eee23c">More...</a><br /></td></tr>
<tr class="separator:a0c24c84baac830cce4d6f528a0eee23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805c30a60f68150f538577aaaab39e74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a805c30a60f68150f538577aaaab39e74">ISR_not_empty</a> (void)</td></tr>
<tr class="memdesc:a805c30a60f68150f538577aaaab39e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue has items in it, from within an ISR.  <a href="#a805c30a60f68150f538577aaaab39e74">More...</a><br /></td></tr>
<tr class="separator:a805c30a60f68150f538577aaaab39e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6084d7ce87cefdfb3891dee4b3dfcfe"><td class="memItemLeft" align="right" valign="top">unsigned portBASE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#af6084d7ce87cefdfb3891dee4b3dfcfe">num_items_in</a> (void)</td></tr>
<tr class="memdesc:af6084d7ce87cefdfb3891dee4b3dfcfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items in the queue.  <a href="#af6084d7ce87cefdfb3891dee4b3dfcfe">More...</a><br /></td></tr>
<tr class="separator:af6084d7ce87cefdfb3891dee4b3dfcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3589846ebd5b842b0b74ffa7e1029af"><td class="memItemLeft" align="right" valign="top">unsigned portBASE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#af3589846ebd5b842b0b74ffa7e1029af">ISR_num_items_in</a> (void)</td></tr>
<tr class="memdesc:af3589846ebd5b842b0b74ffa7e1029af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items in the queue, to an ISR.  <a href="#af3589846ebd5b842b0b74ffa7e1029af">More...</a><br /></td></tr>
<tr class="separator:af3589846ebd5b842b0b74ffa7e1029af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ccb9c99ca4f43304d408d915314d71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#ad5ccb9c99ca4f43304d408d915314d71">print_in_list</a> (<a class="el" href="classemstream.html">emstream</a> *p_ser_dev)</td></tr>
<tr class="memdesc:ad5ccb9c99ca4f43304d408d915314d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the queue's status to a serial device.  <a href="#ad5ccb9c99ca4f43304d408d915314d71">More...</a><br /></td></tr>
<tr class="separator:ad5ccb9c99ca4f43304d408d915314d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d88ebf1c89534addd90863cb0a1015"><td class="memItemLeft" align="right" valign="top">QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a76d88ebf1c89534addd90863cb0a1015">get_handle</a> (void)</td></tr>
<tr class="memdesc:a76d88ebf1c89534addd90863cb0a1015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to the FreeRTOS structure which runs this queue.  <a href="#a76d88ebf1c89534addd90863cb0a1015">More...</a><br /></td></tr>
<tr class="separator:a76d88ebf1c89534addd90863cb0a1015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_base_share"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_base_share')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_base_share.html">BaseShare</a></td></tr>
<tr class="memitem:a9b0cfde3e2ee1869a507e7b8552ccf37 inherit pub_methods_class_base_share"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a9b0cfde3e2ee1869a507e7b8552ccf37">BaseShare</a> (const char *p_name)</td></tr>
<tr class="memdesc:a9b0cfde3e2ee1869a507e7b8552ccf37 inherit pub_methods_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base shared data item.  <a href="class_base_share.html#a9b0cfde3e2ee1869a507e7b8552ccf37">More...</a><br /></td></tr>
<tr class="separator:a9b0cfde3e2ee1869a507e7b8552ccf37 inherit pub_methods_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9e2438ecd0f75063540296b04f3b511e"><td class="memItemLeft" align="right" valign="top"><a id="a9e2438ecd0f75063540296b04f3b511e"></a>
QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a9e2438ecd0f75063540296b04f3b511e">handle</a></td></tr>
<tr class="memdesc:a9e2438ecd0f75063540296b04f3b511e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handle for the queue we use. <br /></td></tr>
<tr class="separator:a9e2438ecd0f75063540296b04f3b511e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad969b6d7fe091778283bc8cc1b6792bd"><td class="memItemLeft" align="right" valign="top"><a id="ad969b6d7fe091778283bc8cc1b6792bd"></a>
TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#ad969b6d7fe091778283bc8cc1b6792bd">ticks_to_wait</a></td></tr>
<tr class="memdesc:ad969b6d7fe091778283bc8cc1b6792bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTOS ticks to wait for empty queue. <br /></td></tr>
<tr class="separator:ad969b6d7fe091778283bc8cc1b6792bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b168989633f215a8f1c8b4a399b8782"><td class="memItemLeft" align="right" valign="top"><a id="a8b168989633f215a8f1c8b4a399b8782"></a>
<a class="el" href="classemstream.html">emstream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#a8b168989633f215a8f1c8b4a399b8782">p_serial</a></td></tr>
<tr class="memdesc:a8b168989633f215a8f1c8b4a399b8782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial device for debugging info. <br /></td></tr>
<tr class="separator:a8b168989633f215a8f1c8b4a399b8782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c4635ceb7cd5f0f331301285b5c211"><td class="memItemLeft" align="right" valign="top"><a id="af4c4635ceb7cd5f0f331301285b5c211"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_queue.html#af4c4635ceb7cd5f0f331301285b5c211">buf_size</a></td></tr>
<tr class="memdesc:af4c4635ceb7cd5f0f331301285b5c211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of queue buffer in bytes. <br /></td></tr>
<tr class="separator:af4c4635ceb7cd5f0f331301285b5c211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_base_share"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_base_share')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_base_share.html">BaseShare</a></td></tr>
<tr class="memitem:af9176a9e2d467ccc1fd05f84bce4f74a inherit pro_attribs_class_base_share"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classemstream.html">emstream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#af9176a9e2d467ccc1fd05f84bce4f74a">p_serial</a></td></tr>
<tr class="memdesc:af9176a9e2d467ccc1fd05f84bce4f74a inherit pro_attribs_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a serial output device used for debugging.  <a href="class_base_share.html#af9176a9e2d467ccc1fd05f84bce4f74a">More...</a><br /></td></tr>
<tr class="separator:af9176a9e2d467ccc1fd05f84bce4f74a inherit pro_attribs_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da759fb6f803ddb8e3883435d91d29a inherit pro_attribs_class_base_share"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a3da759fb6f803ddb8e3883435d91d29a">name</a></td></tr>
<tr class="memdesc:a3da759fb6f803ddb8e3883435d91d29a inherit pro_attribs_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the shared item.  <a href="class_base_share.html#a3da759fb6f803ddb8e3883435d91d29a">More...</a><br /></td></tr>
<tr class="separator:a3da759fb6f803ddb8e3883435d91d29a inherit pro_attribs_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8077022ea40c4ba44a6ff07ab24cac83 inherit pro_attribs_class_base_share"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_base_share.html">BaseShare</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a8077022ea40c4ba44a6ff07ab24cac83">p_next</a></td></tr>
<tr class="memdesc:a8077022ea40c4ba44a6ff07ab24cac83 inherit pro_attribs_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the next item in the linked list of shares.  <a href="class_base_share.html#a8077022ea40c4ba44a6ff07ab24cac83">More...</a><br /></td></tr>
<tr class="separator:a8077022ea40c4ba44a6ff07ab24cac83 inherit pro_attribs_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_attribs_class_base_share"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_class_base_share')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="class_base_share.html">BaseShare</a></td></tr>
<tr class="memitem:a0657d8a02509e79c3bb418aaa9cce33c inherit pro_static_attribs_class_base_share"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_base_share.html">BaseShare</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a0657d8a02509e79c3bb418aaa9cce33c">p_newest</a> = NULL</td></tr>
<tr class="memdesc:a0657d8a02509e79c3bb418aaa9cce33c inherit pro_static_attribs_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the most recently created shared data item.  <a href="class_base_share.html#a0657d8a02509e79c3bb418aaa9cce33c">More...</a><br /></td></tr>
<tr class="separator:a0657d8a02509e79c3bb418aaa9cce33c inherit pro_static_attribs_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class dataType&gt;<br />
class TaskQueue&lt; dataType &gt;</h3>

<p>Implements a queue to transmit data from one RTOS task to another. </p>
<p>Since multithreaded tasks must not use unprotected shared data items for communication, queues are a primary means of intertask communication. Other means include shared data items (see <a class="el" href="taskshare_8h.html" title="Type-safe data which can be shared between tasks in a thread-safe manner. ">taskshare.h</a>) and carrier pigeons. The use of a C++ class template allows the compiler to check that you're putting the right type of data into each queue and getting the right type of data out, thus helping to prevent programming mistakes that can corrupt your data.</p>
<p>As a template class, <code>TaskQueue&lt;dataType&gt;</code> can be used to make queues which hold data of many types. "Plain Old Data" types such as <code>bool</code> or <code>uint16_t</code> are supported, of course. But you can also use queues which hold compound data types. For example, if you have <code>class my_data</code> which holds several measurements together in an object, you can make a queue for <code>my_data</code> objects with <code>TaskQueue&lt;my_data&gt;</code>. Each item in the queue will then hold several measurements. The size of FreeRTOS queues is limited to 255 items in 8-bit microcontrollers whose <code>portBASE_TYPE</code> is an 8-bit number. This is a FreeRTOS feature.</p>
<p>Normal writing and reading are done with methods <code><a class="el" href="class_task_queue.html#ad1dac62fcf253ab0cf50e47654c5fb29" title="Put an item into the queue behind other items. ">put()</a></code> and <code><a class="el" href="class_task_queue.html#a8b696b7e87f4e1bb5cfde83f91dcef75" title="Return and remove the item at the head of the queue. ">get()</a></code>. Normal writing means that the sending task must wait until there is empty space in the queue, and then it puts a data item into the "back" of the queue, where "back" means that the item in the back of the queue will be read after all items that were previously put into the queue have been read. Normal reading means that when an item is read from the front of the queue, it will then be removed, making space for more items at the back. This process is often used to synchronize tasks, as the reading task's <code><a class="el" href="class_task_queue.html#a8b696b7e87f4e1bb5cfde83f91dcef75" title="Return and remove the item at the head of the queue. ">get()</a></code> method blocks, meaning that the reading task gets stuck waiting for an item to arrive in the queue; it won't do anything useful until new data has been read. Note that this is acceptable behavior in an RTOS because the RTOS scheduler will ensure that other tasks get to run even while the reading task is blocking itself waiting for data.</p>
<p>In some cases, one may need to use less normal reading and writing methods. Methods whose name begins with <code>ISR_</code> are to be used only within a hardware interrupt service routine. If one needs to put data at the front of the queue instead of the back, use <code><a class="el" href="class_task_queue.html#a7c2810b4a2137dd88bc72fd1f20d18eb" title="Put an item into the front of the queue to be retrieved first. ">butt_in()</a></code> instead of <code><a class="el" href="class_task_queue.html#ad1dac62fcf253ab0cf50e47654c5fb29" title="Put an item into the queue behind other items. ">put()</a></code>. If one needs to read data from the queue without removing that data, the <code><a class="el" href="class_task_queue.html#a696a695c31e089cf2361f8a16c2fefe6" title="Return the item at the queue head without removing it. ">look_at()</a></code> method allows this to be done. If something particularly unusual needs to be done with the queue, one can use the method <code><a class="el" href="class_task_queue.html#a76d88ebf1c89534addd90863cb0a1015" title="Return a handle to the FreeRTOS structure which runs this queue. ">get_handle()</a></code> to retrieve the handle used by the C language functions in FreeRTOS to access the <a class="el" href="class_task_queue.html" title="Implements a queue to transmit data from one RTOS task to another. ">TaskQueue</a> object's underlying data structure directly.</p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>The following bits of code show how to set up and use a queue to transfer data of type <code>uint16_t</code> from one hypothetical task called <code>task_A</code> to another called <code>task_B</code>.</p>
<p>In the file which contains <code>main()</code> we create a pointer to a queue and use the <code>new</code> operator to create the queue itself. The constructor of the <code>TaskQueue&lt;uint16_t&gt;</code> class is given the number of items in the queue (10) and a name which will appear in some diagnostic printouts. A pointer to a serial port object named <code>serial_port</code> that has previously been created can optionally follow the name: </p><div class="fragment"><div class="line"><a class="code" href="class_task_queue.html">TaskQueue&lt;uint16_t&gt;</a>* p_my_queue;</div><div class="line">...</div><div class="line">main ()</div><div class="line">{</div><div class="line">    ...</div><div class="line">    p_my_queue = <span class="keyword">new</span> <a class="code" href="class_task_queue.html">TaskQueue&lt;uint16_t&gt;</a> (10, <span class="stringliteral">&quot;Data1&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p> In a header file which is read by all the source files in the project we re-declare the queue pointer with the keyword <code>extern</code> to make it globally accessible in all files that <code>#include</code> this header file: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="class_task_queue.html">TaskQueue&lt;uint16_t&gt;</a>* p_my_queue;</div></div><!-- fragment --><p> In the sending task, data is put into the queue: </p><div class="fragment"><div class="line">uint16_t a_data_item;</div><div class="line">...</div><div class="line">p_my_queue-&gt;put (a_data_item);</div></div><!-- fragment --><p> In the receiving task, data is read from the queue. In typical usage, the call to <code>get_out()</code> will block the receiving task until data is put into the queue by the sending task: </p><div class="fragment"><div class="line">uint16_t got_data;</div><div class="line">...</div><div class="line">got_data = p_my_queue-&gt;<a class="code" href="class_task_queue.html#a8b696b7e87f4e1bb5cfde83f91dcef75">get</a> ();</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6eb3342ef8f6413673f1d718c1402385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb3342ef8f6413673f1d718c1402385">&#9670;&nbsp;</a></span>TaskQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::<a class="el" href="class_task_queue.html">TaskQueue</a> </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>queue_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemstream.html">emstream</a> *&#160;</td>
          <td class="paramname"><em>p_ser_dev</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>wait_time</em> = <code>portMAX_DELAY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a queue object, allocating memory for the buffer. </p>
<p>This constructor creates the FreeRTOS queue which is wrapped by the <code><a class="el" href="class_task_queue.html" title="Implements a queue to transmit data from one RTOS task to another. ">TaskQueue</a></code> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_size</td><td>The number of characters which can be stored in the queue </td></tr>
    <tr><td class="paramname">p_name</td><td>A name to be shown in the list of task shares (default <code>NULL</code>) </td></tr>
    <tr><td class="paramname">p_ser_dev</td><td>Pointer to a serial device to be used for debugging printouts Default: <code>NULL</code> </td></tr>
    <tr><td class="paramname">wait_time</td><td>How long, in RTOS ticks, to wait for a full queue to become empty before a character can be sent. Default: <code>portMAX_DELAY</code> which causes the sending task to block until sending occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c2810b4a2137dd88bc72fd1f20d18eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2810b4a2137dd88bc72fd1f20d18eb">&#9670;&nbsp;</a></span>butt_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::butt_in </td>
          <td>(</td>
          <td class="paramtype">const dataType &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an item into the front of the queue to be retrieved first. </p>
<p>This method puts an item into the front of the queue so that it will be received first as long as nothing else is put in front of it. This is not the normal way to put things into a queue; using <code><a class="el" href="class_task_queue.html#ad1dac62fcf253ab0cf50e47654c5fb29" title="Put an item into the queue behind other items. ">put()</a></code> to put items into the back of the queue is. If you always use this method, you're really making a stack rather than a queue, you weirdo. This method must <b>not</b> be used within an interrupt service routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Reference to the item which is going to be (rudely) put into the front of the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item was successfully queued, false if not </dd></dl>

</div>
</div>
<a id="a8b696b7e87f4e1bb5cfde83f91dcef75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b696b7e87f4e1bb5cfde83f91dcef75">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dataType <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return and remove the item at the head of the queue. </p>
<p>This method returns the item at the head of the queue and removes that item from the queue. If there's nothing in the queue, this method waits, blocking the calling task, for the number of RTOS ticks specified in the <code>wait_time</code> parameter to the queue constructor (the default is forever) or until something shows up. </p><dl class="section return"><dt>Returns</dt><dd>The data retrieved from the queue </dd></dl>

</div>
</div>
<a id="a76d88ebf1c89534addd90863cb0a1015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d88ebf1c89534addd90863cb0a1015">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QueueHandle_t <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::get_handle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a handle to the FreeRTOS structure which runs this queue. </p>
<p>If somebody wants to do something which FreeRTOS queues can do but this class doesn't support, a handle for the queue wrapped by this class can be used to access the queue directly. This isn't normally done. </p><dl class="section return"><dt>Returns</dt><dd>The handle of the FreeRTOS queue which is wrapped within this C++ class </dd></dl>

</div>
</div>
<a id="a29c1d8b98bcb89d77919ad9ce69320a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c1d8b98bcb89d77919ad9ce69320a1">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue is empty. </p>
<p>This method checks if the queue is empty. It returns <code>true</code> if there are no items in the queue and <code>false</code> if there are items. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the queue is empty, <code>false</code> if it's not empty </dd></dl>

</div>
</div>
<a id="aa3d85ebdbee24d455f97b37a018f0230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d85ebdbee24d455f97b37a018f0230">&#9670;&nbsp;</a></span>ISR_butt_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::ISR_butt_in </td>
          <td>(</td>
          <td class="paramtype">const dataType &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an item into the front of the queue from within an ISR. </p>
<p>This method puts an item into the front of the queue from within an ISR. It must <b>not</b> be used within normal, non-ISR code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item which is going to be (rudely) put into the front of the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item was successfully queued, false if not </dd></dl>

</div>
</div>
<a id="a57f0fd2a291dacf66983942b82e2997b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f0fd2a291dacf66983942b82e2997b">&#9670;&nbsp;</a></span>ISR_get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dataType <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::ISR_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return and remove the item at the head of the queue from within an ISR. </p>
<p>This method removes and returns the item at the head of the queue from within an interrupt service routine. This method must <b>not</b> be called from within normal non-ISR code. </p><dl class="section return"><dt>Returns</dt><dd>The data retrieved from the queue </dd></dl>

</div>
</div>
<a id="a15630b93ea2a6428aff8234213fac24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15630b93ea2a6428aff8234213fac24f">&#9670;&nbsp;</a></span>ISR_is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::ISR_is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue is empty, from within an ISR. </p>
<p>This method checks if the queue is empty from within an interrupt service routine. It must not be used in normal non-ISR code. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the queue is empty, <code>false</code> if it's not empty </dd></dl>

</div>
</div>
<a id="a5f13cf022edebc95b8c9ca36814a820b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f13cf022edebc95b8c9ca36814a820b">&#9670;&nbsp;</a></span>ISR_look_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dataType <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::ISR_look_at </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the item at the front of the queue without deleting it, from within an ISR. </p>
<p>This method returns the item at the head of the queue without removing that item from the queue. If there's nothing in the queue, this method returns the result of the default constructor for the data item, usually zero in the given data type. This method must <b>not</b> be called from within an interrupt service routine. </p><dl class="section return"><dt>Returns</dt><dd>The data retrieved from the queue; the data is set to 0 in the correct data type if we couldn't get any data from the queue </dd></dl>

</div>
</div>
<a id="a805c30a60f68150f538577aaaab39e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805c30a60f68150f538577aaaab39e74">&#9670;&nbsp;</a></span>ISR_not_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::ISR_not_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue has items in it, from within an ISR. </p>
<p>This method allows one to check if the queue has any contents from within an interrupt service routine. It must <b>not</b> be used from within normal, non-ISR code. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if there's something in the queue, <code>false</code> if not </dd></dl>

</div>
</div>
<a id="af3589846ebd5b842b0b74ffa7e1029af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3589846ebd5b842b0b74ffa7e1029af">&#9670;&nbsp;</a></span>ISR_num_items_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned portBASE_TYPE <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::ISR_num_items_in </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of items in the queue, to an ISR. </p>
<p>This method returns the number of items waiting in the queue; it must be called only from within an interrupt service routine. </p><dl class="section return"><dt>Returns</dt><dd>The number of items in the queue </dd></dl>

</div>
</div>
<a id="a51ff464dfa1c2be2beae36fdd9e36b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ff464dfa1c2be2beae36fdd9e36b44">&#9670;&nbsp;</a></span>ISR_put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::ISR_put </td>
          <td>(</td>
          <td class="paramtype">const dataType &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an item into the queue from within an ISR. </p>
<p>This method puts an item of data into the back of the queue from within an interrupt service routine. It must <b>not</b> be used within non-ISR code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Reference to the item which is going to be put into the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item was successfully queued, false if not </dd></dl>

</div>
</div>
<a id="a696a695c31e089cf2361f8a16c2fefe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696a695c31e089cf2361f8a16c2fefe6">&#9670;&nbsp;</a></span>look_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dataType <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::look_at </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the item at the queue head without removing it. </p>
<p>This method returns the item at the head of the queue without removing that item from the queue. If there's nothing in the queue, this method waits, blocking the calling task, for for the number of RTOS ticks specified in the <code>wait_time</code> parameter to the queue constructor (the default is forever) or until something shows up. This method must <b>not</b> be called from within an interrupt service routine. </p><dl class="section return"><dt>Returns</dt><dd>The data retrieved from the queue; the data is set to 0 in the correct data type if we couldn't get any data from the queue and the attempt timed out </dd></dl>

</div>
</div>
<a id="a0c24c84baac830cce4d6f528a0eee23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c24c84baac830cce4d6f528a0eee23c">&#9670;&nbsp;</a></span>not_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::not_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue has contents which can be read. </p>
<p>This method allows one to check if the queue has any contents. It must <b>not</b> be called from within an interrupt service routine. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if there's something in the queue, <code>false</code> if not </dd></dl>

</div>
</div>
<a id="af6084d7ce87cefdfb3891dee4b3dfcfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6084d7ce87cefdfb3891dee4b3dfcfe">&#9670;&nbsp;</a></span>num_items_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned portBASE_TYPE <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::num_items_in </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of items in the queue. </p>
<p>This method returns the number of items waiting in the queue. It must <b>not</b> be called from within an interrupt service routine; the method <code><a class="el" href="class_task_queue.html#af3589846ebd5b842b0b74ffa7e1029af" title="Return the number of items in the queue, to an ISR. ">ISR_num_items_in()</a></code> can be called from within an ISR. </p><dl class="section return"><dt>Returns</dt><dd>The number of items in the queue </dd></dl>

</div>
</div>
<a id="ad5ccb9c99ca4f43304d408d915314d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ccb9c99ca4f43304d408d915314d71">&#9670;&nbsp;</a></span>print_in_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::print_in_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemstream.html">emstream</a> *&#160;</td>
          <td class="paramname"><em>p_ser_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the queue's status to a serial device. </p>
<p>This method makes a printout of the queue's status on the given serial device, then calls this same method for the next item of thread-safe data in the linked list of items. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_ser_dev</td><td>Pointer to the serial device on which to print </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_base_share.html#a81ef685c8c1897ee316e853103e9941a">BaseShare</a>.</p>

</div>
</div>
<a id="ad1dac62fcf253ab0cf50e47654c5fb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dac62fcf253ab0cf50e47654c5fb29">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_task_queue.html">TaskQueue</a>&lt; dataType &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const dataType &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an item into the queue behind other items. </p>
<p>This method puts an item of data into the back of the queue, which is the normal way to put something into a queue. If you want to be rude and put an item into the front of the queue so it will be retreived first, use <code><a class="el" href="class_task_queue.html#a7c2810b4a2137dd88bc72fd1f20d18eb" title="Put an item into the front of the queue to be retrieved first. ">butt_in()</a></code> instead. This method must <b>not</b> be used within an ISR. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Reference to the item which is going to be put into the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item was successfully queued, false if not </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/frtcpp/<a class="el" href="taskqueue_8h_source.html">taskqueue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
