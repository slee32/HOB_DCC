<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HOB_DCC: circ_buffer&lt; qType, qSize &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HOBPoster.2018.12.07.2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HOB_DCC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcirc__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">circ_buffer&lt; qType, qSize &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements a simple first-in, first-out circular buffer.  
 <a href="classcirc__buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="circ__buffer_8h_source.html">circ_buffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13022e03168d09485d60586ff986d99e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#a13022e03168d09485d60586ff986d99e">circ_buffer</a> (void)</td></tr>
<tr class="separator:a13022e03168d09485d60586ff986d99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7318942bb1ff23d4e54730e9207563ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#a7318942bb1ff23d4e54730e9207563ad">put</a> (qType)</td></tr>
<tr class="separator:a7318942bb1ff23d4e54730e9207563ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5809d3a7ee58d8154b88aa9d8e427456"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#a5809d3a7ee58d8154b88aa9d8e427456">jam</a> (qType)</td></tr>
<tr class="separator:a5809d3a7ee58d8154b88aa9d8e427456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346c872e2a22533624121125745c2bcd"><td class="memItemLeft" align="right" valign="top">qType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#a346c872e2a22533624121125745c2bcd">get</a> (void)</td></tr>
<tr class="separator:a346c872e2a22533624121125745c2bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fb88d9f94bacee4b3e4c2c59005f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#a08fb88d9f94bacee4b3e4c2c59005f4c">flush</a> (void)</td></tr>
<tr class="separator:a08fb88d9f94bacee4b3e4c2c59005f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49d0b5197d10db6e0ec0725579cee7d"><td class="memItemLeft" align="right" valign="top">qType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#ae49d0b5197d10db6e0ec0725579cee7d">operator[]</a> (size_t)</td></tr>
<tr class="separator:ae49d0b5197d10db6e0ec0725579cee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae773723a48273a885c23eaec4e0862a7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#ae773723a48273a885c23eaec4e0862a7">num_items</a> (void)</td></tr>
<tr class="separator:ae773723a48273a885c23eaec4e0862a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8646ef0af4f2c1a630e4ac3b4cc015fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#a8646ef0af4f2c1a630e4ac3b4cc015fb">is_empty</a> (void)</td></tr>
<tr class="separator:a8646ef0af4f2c1a630e4ac3b4cc015fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4634119ccb74fd6a2c7decccb3fcd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#a3f4634119ccb74fd6a2c7decccb3fcd3">is_full</a> (void)</td></tr>
<tr class="separator:a3f4634119ccb74fd6a2c7decccb3fcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af106f433dd4211c933e023af5735f9d5"><td class="memItemLeft" align="right" valign="top">qType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#af106f433dd4211c933e023af5735f9d5">get_p_buffer</a> (void)</td></tr>
<tr class="separator:af106f433dd4211c933e023af5735f9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0e092ba5a730b69302e6baaea536b8b7"><td class="memItemLeft" align="right" valign="top"><a id="a0e092ba5a730b69302e6baaea536b8b7"></a>
qType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#a0e092ba5a730b69302e6baaea536b8b7">buffer</a> [qSize]</td></tr>
<tr class="memdesc:a0e092ba5a730b69302e6baaea536b8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This memory buffer holds the contents. <br /></td></tr>
<tr class="separator:a0e092ba5a730b69302e6baaea536b8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fdb14e6ae3342e78c3e7428554804d"><td class="memItemLeft" align="right" valign="top"><a id="ae4fdb14e6ae3342e78c3e7428554804d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#ae4fdb14e6ae3342e78c3e7428554804d">i_put</a></td></tr>
<tr class="memdesc:ae4fdb14e6ae3342e78c3e7428554804d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index where newest data will be written. <br /></td></tr>
<tr class="separator:ae4fdb14e6ae3342e78c3e7428554804d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ea70143b72d982d6e08929faddf47a"><td class="memItemLeft" align="right" valign="top"><a id="ac3ea70143b72d982d6e08929faddf47a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#ac3ea70143b72d982d6e08929faddf47a">i_get</a></td></tr>
<tr class="memdesc:ac3ea70143b72d982d6e08929faddf47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index where oldest data was written. <br /></td></tr>
<tr class="separator:ac3ea70143b72d982d6e08929faddf47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef3618c481f06b4b45b8f204662abd1"><td class="memItemLeft" align="right" valign="top"><a id="a8ef3618c481f06b4b45b8f204662abd1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirc__buffer.html#a8ef3618c481f06b4b45b8f204662abd1">how_full</a></td></tr>
<tr class="memdesc:a8ef3618c481f06b4b45b8f204662abd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many elements are full at this time. <br /></td></tr>
<tr class="separator:a8ef3618c481f06b4b45b8f204662abd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class qType, size_t qSize&gt;<br />
class circ_buffer&lt; qType, qSize &gt;</h3>

<p>This class implements a simple first-in, first-out circular buffer. </p>
<p>As a template class, it can be used to create a buffer which holds any type of object whose data is copied with an assignment operator. The size and type of object are determined at compile time for efficiency. This is <b>not</b> the same as an RTOS queue which transmits data from one task to another; a <code><a class="el" href="classcirc__buffer.html" title="This class implements a simple first-in, first-out circular buffer. ">circ_buffer</a>&lt;qType</code>,<code>qSize&gt;</code> has no components to make it thread-safe nor to interact with an RTOS scheduler in any way.</p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>To create a buffer of this type, declare an object of this type, specifying as template parameters the type of data in the buffer and the number of items in the buffer. As an example, to create a buffer which holds 100 16-bit integers: </p><div class="fragment"><div class="line"><a class="code" href="classcirc__buffer.html">circ_buffer&lt;int16_t, 100&gt;</a> my_queue;</div></div><!-- fragment --><p>One can also create buffers which hold objects of a class. If one has created a class called <code>data_item</code> whose objects each hold a bunch of data, one can make a circular buffer which holds a bunch of <code>data_item</code> objects: </p><div class="fragment"><div class="line"><a class="code" href="classcirc__buffer.html">circ_buffer&lt;data_item, 320&gt;</a> my_BIG_buff;</div></div><!-- fragment --><p> One must be careful when making buffers not to use too much RAM, as small microcontrollers usually don't have much of it. If a <code>data_item</code> object has 5 <code>uint16_t</code> integers to store A/D readings, for example, the data storage for <code>my_BIG_buff</code> will be over 3KB in size, which is most of the memory of an ATmega128; not enough memory will be left for task stacks and the RTOS itself.</p>
<p>Entering data into the buffer is done with the <code><a class="el" href="classcirc__buffer.html#a7318942bb1ff23d4e54730e9207563ad">put()</a></code> method: </p><div class="fragment"><div class="line">uint16_t some_data;</div><div class="line">...</div><div class="line">my_queue.put (some_data);</div></div><!-- fragment --><p> The <code><a class="el" href="classcirc__buffer.html#a7318942bb1ff23d4e54730e9207563ad">put()</a></code> method will only put data into the buffer if there is empty space for the data; a full buffer will not allow data to be written into it unless the <code><a class="el" href="classcirc__buffer.html#a5809d3a7ee58d8154b88aa9d8e427456">jam()</a></code> method is used instead. Using <code><a class="el" href="classcirc__buffer.html#a5809d3a7ee58d8154b88aa9d8e427456">jam()</a></code> will overwrite existing data.</p>
<p>Data is retrieved from the buffer with the <code><a class="el" href="classcirc__buffer.html#a346c872e2a22533624121125745c2bcd">get()</a></code> method. It is usually a good idea to check if anything is in the buffer before attempting to retrieve data so that an empty buffer can be handled gracefully: </p><div class="fragment"><div class="line">uint16_t an_item;</div><div class="line">...</div><div class="line">if (my_queue.<a class="code" href="classcirc__buffer.html#a8646ef0af4f2c1a630e4ac3b4cc015fb">is_empty</a> ())</div><div class="line">{</div><div class="line">    <span class="comment">// Do something which handles an empty buffer without causing trouble.</span></div><div class="line">    <span class="comment">// Sometimes that means to just do something else until data arrives</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    an_item = my_queue.<a class="code" href="classcirc__buffer.html#a346c872e2a22533624121125745c2bcd">get</a> ();</div><div class="line">}</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a13022e03168d09485d60586ff986d99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13022e03168d09485d60586ff986d99e">&#9670;&nbsp;</a></span>circ_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class qType , size_t qSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcirc__buffer.html">circ_buffer</a>&lt; qType, qSize &gt;::<a class="el" href="classcirc__buffer.html">circ_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor creates a circular buffer object. Note that it doesn't have to allocate memory because that was already done statically by the template mechanism at compile time. If no parameters are supplied, a 16-element buffer for characters which uses 8-bit array indices (for a maximum of 255 elements) is created. The template parameters are as follows: </p><ul>
<li>qType: The type of data which will be stored in the buffer (default char) </li>
<li>qSize: The number of items in the buffer's memory area (default 16). This is the number of items of the given data type, <b>not</b> the number of bytes needed to store all that data </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a08fb88d9f94bacee4b3e4c2c59005f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fb88d9f94bacee4b3e4c2c59005f4c">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class qType , size_t qSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcirc__buffer.html">circ_buffer</a>&lt; qType, qSize &gt;::flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method empties the buffer. It doesn't actually erase everything; it just sets the indices and fill indicator all to zero as if the buffer contained nothing. </p>

</div>
</div>
<a id="a346c872e2a22533624121125745c2bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346c872e2a22533624121125745c2bcd">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class qType , size_t qSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">qType <a class="el" href="classcirc__buffer.html">circ_buffer</a>&lt; qType, qSize &gt;::get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns the oldest item in the buffer. If the buffer was empty, this is already-retreived data, and somebody should have checked if there was new data available using the <code><a class="el" href="classcirc__buffer.html#a8646ef0af4f2c1a630e4ac3b4cc015fb">is_empty()</a></code> method. </p><dl class="section return"><dt>Returns</dt><dd>The data which is pulled out from the buffer at the current location </dd></dl>

</div>
</div>
<a id="af106f433dd4211c933e023af5735f9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af106f433dd4211c933e023af5735f9d5">&#9670;&nbsp;</a></span>get_p_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class qType, size_t qSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">qType* <a class="el" href="classcirc__buffer.html">circ_buffer</a>&lt; qType, qSize &gt;::get_p_buffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns a pointer to the buffer which holds the data in the queue. Normally it's not used, but in some cases (particularly queues of characters) one may need to access the data buffer directly. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the buffer holding the data in the queue </dd></dl>

</div>
</div>
<a id="a8646ef0af4f2c1a630e4ac3b4cc015fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8646ef0af4f2c1a630e4ac3b4cc015fb">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class qType, size_t qSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcirc__buffer.html">circ_buffer</a>&lt; qType, qSize &gt;::is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns true if the buffer is empty. Empty means that there isn't any data which hasn't previously been read. </p><dl class="section return"><dt>Returns</dt><dd>True if the buffer has unread data, false if it doesn't </dd></dl>

</div>
</div>
<a id="a3f4634119ccb74fd6a2c7decccb3fcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4634119ccb74fd6a2c7decccb3fcd3">&#9670;&nbsp;</a></span>is_full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class qType, size_t qSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcirc__buffer.html">circ_buffer</a>&lt; qType, qSize &gt;::is_full </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns true if the buffer is full. </p><dl class="section return"><dt>Returns</dt><dd>True if the buffer is full, false if there is empty space left </dd></dl>

</div>
</div>
<a id="a5809d3a7ee58d8154b88aa9d8e427456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5809d3a7ee58d8154b88aa9d8e427456">&#9670;&nbsp;</a></span>jam()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class qType, size_t qSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcirc__buffer.html">circ_buffer</a>&lt; qType, qSize &gt;::jam </td>
          <td>(</td>
          <td class="paramtype">qType&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method jams an item into the buffer whether the buffer is empty or not. This can overwrite existing data, so it must be used with caution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be jammed into the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if some data was lost, true otherwise </dd></dl>

</div>
</div>
<a id="ae773723a48273a885c23eaec4e0862a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae773723a48273a885c23eaec4e0862a7">&#9670;&nbsp;</a></span>num_items()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class qType, size_t qSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcirc__buffer.html">circ_buffer</a>&lt; qType, qSize &gt;::num_items </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the number of items in the buffer. </p><dl class="section return"><dt>Returns</dt><dd>The number of items currently in the buffer </dd></dl>

</div>
</div>
<a id="ae49d0b5197d10db6e0ec0725579cee7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49d0b5197d10db6e0ec0725579cee7d">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class qType , size_t qSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">qType <a class="el" href="classcirc__buffer.html">circ_buffer</a>&lt; qType, qSize &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overloaded array subscript operator implements subscripts in the buffer. The index is defined relative to the location at which the oldest data in the buffer was written. This operator returns the (index)-th item in the buffer, or (-1) typecast to the data type if there aren't enough items in the buffer to get to the given index. The retreived data is not removed from the buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The array index into the buffer at which to get a data item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data which is at the given index </dd></dl>

</div>
</div>
<a id="a7318942bb1ff23d4e54730e9207563ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7318942bb1ff23d4e54730e9207563ad">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class qType, size_t qSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcirc__buffer.html">circ_buffer</a>&lt; qType, qSize &gt;::put </td>
          <td>(</td>
          <td class="paramtype">qType&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method adds an item into the buffer. If the buffer is full then nothing is written and false (meaning buffer is full) is returned. This allows the calling program to see that the data couldn't be written and try again if appropriate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written into the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the buffer was full and data was not written, true otherwise </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/misc/<a class="el" href="circ__buffer_8h_source.html">circ_buffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
