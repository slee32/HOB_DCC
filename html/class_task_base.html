<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HOB_DCC: TaskBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HOBPoster.2018.12.07.2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HOB_DCC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_task_base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TaskBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for implementations of tasks in task/state based programs.  
 <a href="class_task_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="taskbase_8h_source.html">taskbase.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TaskBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_task_base.png" usemap="#TaskBase_map" alt=""/>
  <map id="TaskBase_map" name="TaskBase_map">
<area href="class_d_c_c.html" title="DCC controller, child of TaskBase. " alt="DCC" shape="rect" coords="0,56,80,80"/>
<area href="class_flip___flap.html" title="Flip flap controller class, child of TaskBase. " alt="Flip_Flap" shape="rect" coords="90,56,170,80"/>
<area href="classtask__multi.html" alt="task_multi" shape="rect" coords="180,56,260,80"/>
<area href="classtask__sink.html" alt="task_sink" shape="rect" coords="270,56,350,80"/>
<area href="classtask__source.html" alt="task_source" shape="rect" coords="360,56,440,80"/>
<area href="classtask__user.html" alt="task_user" shape="rect" coords="450,56,530,80"/>
<area href="classtask__user.html" alt="task_user" shape="rect" coords="540,56,620,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae8e359a838bed17302e4f21146dba612"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#ae8e359a838bed17302e4f21146dba612">TaskBase</a> (const char *a_name, unsigned portBASE_TYPE a_priority=0, size_t a_stack_size=configMINIMAL_STACK_SIZE, <a class="el" href="classemstream.html">emstream</a> *p_ser_dev=NULL)</td></tr>
<tr class="memdesc:ae8e359a838bed17302e4f21146dba612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which creates and initializes a task object.  <a href="#ae8e359a838bed17302e4f21146dba612">More...</a><br /></td></tr>
<tr class="separator:ae8e359a838bed17302e4f21146dba612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf6036ad9c860051ccf392ba5e7dbbc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc">run</a> (void)=0</td></tr>
<tr class="memdesc:adcf6036ad9c860051ccf392ba5e7dbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run method which holds the user's task code.  <a href="#adcf6036ad9c860051ccf392ba5e7dbbc">More...</a><br /></td></tr>
<tr class="separator:adcf6036ad9c860051ccf392ba5e7dbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70bf7c9cb6dfccdb1dbf41b7c6d2ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#af70bf7c9cb6dfccdb1dbf41b7c6d2ecf">transition_to</a> (uint8_t)</td></tr>
<tr class="memdesc:af70bf7c9cb6dfccdb1dbf41b7c6d2ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause this task to transition to another state.  <a href="#af70bf7c9cb6dfccdb1dbf41b7c6d2ecf">More...</a><br /></td></tr>
<tr class="separator:af70bf7c9cb6dfccdb1dbf41b7c6d2ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad088ca82db29301b019b1efde85156be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#ad088ca82db29301b019b1efde85156be">set_serial_device</a> (<a class="el" href="classemstream.html">emstream</a> *p_new_dev)</td></tr>
<tr class="memdesc:ad088ca82db29301b019b1efde85156be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the task's serial device pointer.  <a href="#ad088ca82db29301b019b1efde85156be">More...</a><br /></td></tr>
<tr class="separator:ad088ca82db29301b019b1efde85156be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1cc480afef3708598b6b217b281a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a0e1cc480afef3708598b6b217b281a7b">unset_serial_device</a> (void)</td></tr>
<tr class="memdesc:a0e1cc480afef3708598b6b217b281a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off serial logging by un-setting the task's serial pointer.  <a href="#a0e1cc480afef3708598b6b217b281a7b">More...</a><br /></td></tr>
<tr class="separator:a0e1cc480afef3708598b6b217b281a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbf9678429543f33c9c8f82511a3887"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a0dbf9678429543f33c9c8f82511a3887">operator bool</a> () const</td></tr>
<tr class="memdesc:a0dbf9678429543f33c9c8f82511a3887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a task is ready to run.  <a href="#a0dbf9678429543f33c9c8f82511a3887">More...</a><br /></td></tr>
<tr class="separator:a0dbf9678429543f33c9c8f82511a3887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d9c962cc578a84a69ca637f6d5adef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a06d9c962cc578a84a69ca637f6d5adef">delay</a> (TickType_t duration)</td></tr>
<tr class="memdesc:a06d9c962cc578a84a69ca637f6d5adef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop running the task for the given number of RTOS ticks.  <a href="#a06d9c962cc578a84a69ca637f6d5adef">More...</a><br /></td></tr>
<tr class="separator:a06d9c962cc578a84a69ca637f6d5adef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7e9bc3d85a0e71462002b85402d995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a6a7e9bc3d85a0e71462002b85402d995">delay_ms</a> (TickType_t duration_ms)</td></tr>
<tr class="memdesc:a6a7e9bc3d85a0e71462002b85402d995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the task for approximately the given number of milliseconds.  <a href="#a6a7e9bc3d85a0e71462002b85402d995">More...</a><br /></td></tr>
<tr class="separator:a6a7e9bc3d85a0e71462002b85402d995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc48db72592a8b34ca1235e1d18604cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#adc48db72592a8b34ca1235e1d18604cc">delay_from_for</a> (TickType_t &amp;from_ticks, TickType_t for_how_long)</td></tr>
<tr class="memdesc:adc48db72592a8b34ca1235e1d18604cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the task from running for a precise time interval.  <a href="#adc48db72592a8b34ca1235e1d18604cc">More...</a><br /></td></tr>
<tr class="separator:adc48db72592a8b34ca1235e1d18604cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b1c01059c7ec4bfe60fc8332759551"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a31b1c01059c7ec4bfe60fc8332759551">delay_from_for_ms</a> (TickType_t &amp;from_ticks, TickType_t millisec)</td></tr>
<tr class="memdesc:a31b1c01059c7ec4bfe60fc8332759551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the task from running for a precise number of milliseconds.  <a href="#a31b1c01059c7ec4bfe60fc8332759551">More...</a><br /></td></tr>
<tr class="separator:a31b1c01059c7ec4bfe60fc8332759551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea05d3d35f6cbda823ed4812b0951944"><td class="memItemLeft" align="right" valign="top">TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#aea05d3d35f6cbda823ed4812b0951944">get_tick_count</a> (void)</td></tr>
<tr class="memdesc:aea05d3d35f6cbda823ed4812b0951944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out how many RTOS ticks since the scheduler was started.  <a href="#aea05d3d35f6cbda823ed4812b0951944">More...</a><br /></td></tr>
<tr class="separator:aea05d3d35f6cbda823ed4812b0951944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9fe49dbbf245e182abf6d17c9bd3df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a4e9fe49dbbf245e182abf6d17c9bd3df">yield</a> (void)</td></tr>
<tr class="memdesc:a4e9fe49dbbf245e182abf6d17c9bd3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task gives control to the RTOS immediately.  <a href="#a4e9fe49dbbf245e182abf6d17c9bd3df">More...</a><br /></td></tr>
<tr class="separator:a4e9fe49dbbf245e182abf6d17c9bd3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f26fc9564898da36d2355095c204340"><td class="memItemLeft" align="right" valign="top">portBASE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a1f26fc9564898da36d2355095c204340">get_priority</a> (void)</td></tr>
<tr class="memdesc:a1f26fc9564898da36d2355095c204340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task's current priority.  <a href="#a1f26fc9564898da36d2355095c204340">More...</a><br /></td></tr>
<tr class="separator:a1f26fc9564898da36d2355095c204340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6f54b0b07cf27d5764c4dca5ec5fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a1a6f54b0b07cf27d5764c4dca5ec5fcf">set_priority</a> (portBASE_TYPE new_priority)</td></tr>
<tr class="memdesc:a1a6f54b0b07cf27d5764c4dca5ec5fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this task's priority to a new value.  <a href="#a1a6f54b0b07cf27d5764c4dca5ec5fcf">More...</a><br /></td></tr>
<tr class="separator:a1a6f54b0b07cf27d5764c4dca5ec5fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822796dba0ef4d457608363507d65f5a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a822796dba0ef4d457608363507d65f5a">heap_left</a> (void)</td></tr>
<tr class="memdesc:a822796dba0ef4d457608363507d65f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of unused bytes in the heap.  <a href="#a822796dba0ef4d457608363507d65f5a">More...</a><br /></td></tr>
<tr class="separator:a822796dba0ef4d457608363507d65f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e228e424048594a935cd31ae9e0eeb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a9e228e424048594a935cd31ae9e0eeb3">dump_stack</a> (<a class="el" href="classemstream.html">emstream</a> *p_ser_dev)</td></tr>
<tr class="memdesc:a9e228e424048594a935cd31ae9e0eeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a display of this task's stack space.  <a href="#a9e228e424048594a935cd31ae9e0eeb3">More...</a><br /></td></tr>
<tr class="separator:a9e228e424048594a935cd31ae9e0eeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441138caa57e35f58f31dc4d960580d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a441138caa57e35f58f31dc4d960580d9">print_stack_in_list</a> (<a class="el" href="classemstream.html">emstream</a> *p_ser_dev)</td></tr>
<tr class="memdesc:a441138caa57e35f58f31dc4d960580d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a stack dump within a dump of all tasks' stacks.  <a href="#a441138caa57e35f58f31dc4d960580d9">More...</a><br /></td></tr>
<tr class="separator:a441138caa57e35f58f31dc4d960580d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3979e41ecb8f646f12d4283d87f93df"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#aa3979e41ecb8f646f12d4283d87f93df">get_total_stack</a> (void)</td></tr>
<tr class="memdesc:aa3979e41ecb8f646f12d4283d87f93df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total stack size for this task.  <a href="#aa3979e41ecb8f646f12d4283d87f93df">More...</a><br /></td></tr>
<tr class="separator:aa3979e41ecb8f646f12d4283d87f93df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f412b0911d4cf84dad9169a10c46e0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#ae4f412b0911d4cf84dad9169a10c46e0">get_state</a> (void)</td></tr>
<tr class="memdesc:ae4f412b0911d4cf84dad9169a10c46e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current state in which this task's state machine is.  <a href="#ae4f412b0911d4cf84dad9169a10c46e0">More...</a><br /></td></tr>
<tr class="separator:ae4f412b0911d4cf84dad9169a10c46e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0769068c3095d76752e0a00963d8b8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a4d0769068c3095d76752e0a00963d8b8">get_tick_time</a> (void)</td></tr>
<tr class="memdesc:a4d0769068c3095d76752e0a00963d8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an approximate measurement of time from the tick count.  <a href="#a4d0769068c3095d76752e0a00963d8b8">More...</a><br /></td></tr>
<tr class="separator:a4d0769068c3095d76752e0a00963d8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b0a4031cf715d9d3a6ecd3b29f5cbe"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a69b0a4031cf715d9d3a6ecd3b29f5cbe">get_name</a> (void)</td></tr>
<tr class="memdesc:a69b0a4031cf715d9d3a6ecd3b29f5cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to this task's name.  <a href="#a69b0a4031cf715d9d3a6ecd3b29f5cbe">More...</a><br /></td></tr>
<tr class="separator:a69b0a4031cf715d9d3a6ecd3b29f5cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bd479a964b4c98da9f8f1a6b08efd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a58bd479a964b4c98da9f8f1a6b08efd7">print_status_in_list</a> (<a class="el" href="classemstream.html">emstream</a> *)</td></tr>
<tr class="separator:a58bd479a964b4c98da9f8f1a6b08efd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2113de68c720fcf8b643b11a43b84ab7"><td class="memItemLeft" align="right" valign="top">TaskHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a2113de68c720fcf8b643b11a43b84ab7">get_handle</a> (void)</td></tr>
<tr class="memdesc:a2113de68c720fcf8b643b11a43b84ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to the FreeRTOS task wrapped by this task object.  <a href="#a2113de68c720fcf8b643b11a43b84ab7">More...</a><br /></td></tr>
<tr class="separator:a2113de68c720fcf8b643b11a43b84ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea504e1e3d38a7e8e8c65c4284d4a560"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#aea504e1e3d38a7e8e8c65c4284d4a560">print_status</a> (<a class="el" href="classemstream.html">emstream</a> &amp;)</td></tr>
<tr class="separator:aea504e1e3d38a7e8e8c65c4284d4a560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5842a497b5a274e6a40fae18bff03a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a5842a497b5a274e6a40fae18bff03a9f">emergency_reset</a> (const char *message)</td></tr>
<tr class="memdesc:a5842a497b5a274e6a40fae18bff03a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an error message if possible and reset the processor.  <a href="#a5842a497b5a274e6a40fae18bff03a9f">More...</a><br /></td></tr>
<tr class="separator:a5842a497b5a274e6a40fae18bff03a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9884c542600faa2f90da35c832fea87a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a9884c542600faa2f90da35c832fea87a">_call_users_run_method</a> (<a class="el" href="class_task_base.html">TaskBase</a> *)</td></tr>
<tr class="memdesc:a9884c542600faa2f90da35c832fea87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only function which calls the <code><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a></code> method.  <a href="#a9884c542600faa2f90da35c832fea87a">More...</a><br /></td></tr>
<tr class="separator:a9884c542600faa2f90da35c832fea87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6efe1287e0d4b73064af05626e48d2"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_task_base.html">TaskBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a6d6efe1287e0d4b73064af05626e48d2">get_last_created_task_pointer</a> (void)</td></tr>
<tr class="memdesc:a6d6efe1287e0d4b73064af05626e48d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the most recently created task.  <a href="#a6d6efe1287e0d4b73064af05626e48d2">More...</a><br /></td></tr>
<tr class="separator:a6d6efe1287e0d4b73064af05626e48d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adbc9cc6b14c5396c38457edc9c9bc215"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#adbc9cc6b14c5396c38457edc9c9bc215">get_loop_runs</a> (void)</td></tr>
<tr class="separator:adbc9cc6b14c5396c38457edc9c9bc215"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abd349e5f74bd10d1288459b66858ea26"><td class="memItemLeft" align="right" valign="top"><a id="abd349e5f74bd10d1288459b66858ea26"></a>
TaskHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#abd349e5f74bd10d1288459b66858ea26">handle</a></td></tr>
<tr class="memdesc:abd349e5f74bd10d1288459b66858ea26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the handle of this RTOS task. It's typedef'd as a pointer type. <br /></td></tr>
<tr class="separator:abd349e5f74bd10d1288459b66858ea26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8adbe534975ada5ffb46fa403ef07f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_task_base.html">TaskBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a4f8adbe534975ada5ffb46fa403ef07f">prev_task_pointer</a></td></tr>
<tr class="separator:a4f8adbe534975ada5ffb46fa403ef07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5299f7fa222eb0ddac3b77e667170fd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classemstream.html">emstream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a5299f7fa222eb0ddac3b77e667170fd7">p_serial</a></td></tr>
<tr class="separator:a5299f7fa222eb0ddac3b77e667170fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6866bbd5d036810829ccc7cd3ab0e8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#aab6866bbd5d036810829ccc7cd3ab0e8">state</a></td></tr>
<tr class="separator:aab6866bbd5d036810829ccc7cd3ab0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9736ccdb46487c91c49bdbf2c24b52d3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#a9736ccdb46487c91c49bdbf2c24b52d3">previous_state</a></td></tr>
<tr class="separator:a9736ccdb46487c91c49bdbf2c24b52d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5503939e17359f0f3f9249f622df389"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_base.html#ab5503939e17359f0f3f9249f622df389">runs</a></td></tr>
<tr class="separator:ab5503939e17359f0f3f9249f622df389"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for implementations of tasks in task/state based programs. </p>
<p>This class is a C++ wrapper for the FreeRTOS task functions with some extra functionality for keeping track of state transitions and for printing diagnostic information about how tasks are configured and how they are running.</p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>In order to use a task, one must first create a child class of class <code><a class="el" href="class_task_base.html" title="Base class for implementations of tasks in task/state based programs. ">TaskBase</a></code>. The child class must at least have a constructor and a run method: </p><div class="fragment"><div class="line"><span class="keyword">class </span>TaskExample : <span class="keyword">public</span> <a class="code" href="class_task_base.html">TaskBase</a></div><div class="line">{</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="comment">// Task specific data goes here</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// This constructor creates an example task object</span></div><div class="line">       TaskExample (<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keywordtype">unsigned</span> portBASE_TYPE, <span class="keywordtype">size_t</span>, <a class="code" href="classemstream.html">emstream</a>*);</div><div class="line"></div><div class="line">    <span class="comment">// This run method is called by the RTOS and contains a loop </span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc">run</a> (<span class="keywordtype">void</span>);</div><div class="line">};</div></div><!-- fragment --><p>The task class's constructor can sometimes be quite simple, only calling the parent constructor as shown in the example below: </p><div class="fragment"><div class="line">TaskExample::TaskExample (<span class="keyword">const</span> <span class="keywordtype">char</span>* a_name,</div><div class="line">                          <span class="keywordtype">unsigned</span> portBASE_TYPE a_priority,</div><div class="line">                          <span class="keywordtype">size_t</span> a_stack_size,</div><div class="line">                          <a class="code" href="classemstream.html">emstream</a>* p_serial_dev</div><div class="line">                         )</div><div class="line">    : <a class="code" href="class_task_base.html">TaskBase</a> (a_name, a_priority, a_stack_size, p_serial_dev)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p> If the task needs to initialize device drivers or other things it owns, that can be done in the constructor.</p>
<p>Every task must have a user-written run method named <code><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a></code>. The run method is where most of the functionality of the task is implemented. The run method must contain an endless loop in which the task's state machine is implemented. A variable called <code>state</code> is kept by the parent class <code><a class="el" href="class_task_base.html" title="Base class for implementations of tasks in task/state based programs. ">TaskBase</a></code> and used to monitor the state in which the user's code is running, so one should <b>not</b> declare another variable called <code>state</code> inside the run method: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> TaskExample::run (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    portTickType LastWakeTime;                 <span class="comment">// For scheduling how often task runs</span></div><div class="line"></div><div class="line">    <span class="comment">// Initialise the LastWakeTime variable with the current time. This happens just</span></div><div class="line">    <span class="comment">// once, before the infinite loop is entered</span></div><div class="line">       LastWakeTime = <a class="code" href="class_task_base.html#aea05d3d35f6cbda823ed4812b0951944">get_tick_count</a> ();</div><div class="line"></div><div class="line">    <span class="comment">// This is the task loop. Once the task has been initialized in the code just</span></div><div class="line">    <span class="comment">// above, the task loop runs, and it keeps running until the power is shut off</span></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line">        <span class="comment">// Run the task&#39;s state machine here</span></div><div class="line">        <span class="keywordflow">switch</span> (<a class="code" href="class_task_base.html#aab6866bbd5d036810829ccc7cd3ab0e8">state</a>)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">case</span> 0:</div><div class="line">                <span class="comment">// Do one thing in State 0</span></div><div class="line">                ...</div><div class="line">                <span class="comment">// Check for a transition to another state</span></div><div class="line">                <span class="keywordflow">if</span> (something)</div><div class="line">                {</div><div class="line">                    <a class="code" href="class_task_base.html#af70bf7c9cb6dfccdb1dbf41b7c6d2ecf">transition_to</a> (1);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> 1:</div><div class="line">                <span class="comment">// Do another thing in State 1</span></div><div class="line">                ...</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> 2:</div><div class="line">                <span class="comment">// Do something completely different in State 2</span></div><div class="line">                ...</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="comment">// Tell the RTOS to delay until the given number of RTOS timer ticks have</span></div><div class="line">        <span class="comment">// elapsed. This means the code after this line runs every ticks_per_run</span></div><div class="line">        <span class="comment">// milliseconds if the RTOS interrupt is set to go off every 1 millisecond</span></div><div class="line">        <a class="code" href="class_task_base.html#adc48db72592a8b34ca1235e1d18604cc">delay_from_for</a> (LastWakeTime, ticks_per_run);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Tasks are traditionally instantiated within <code>main()</code>. The most important and tricky part about creating a task is getting its <b>stack</b> size right. If a task's stack is too large, it will waste RAM, and small microcontrollers don't have much RAM to waste. If the task's stack is too small, it will cause disaster, usually in the form of the processor either hanging or rebooting as the stack pointer for the task goes outside the allocated range and overwrites the stack for another task. For FreeRTOS tasks on an 8-bit AVR microcontroller, the smallest stack size that is likely to ever work is about 100 bytes. As soon as data is created within the run method, queues are used, and other memory is used, the necessary stack size goes up; it is common to need 300 &ndash; 500 bytes of stack space for a task that does a lot of work. Because it's very difficult to calculate the stack space needed for a task, the easiest way to set the stack size is usually to make it large enough that the program runs reliably, then decrease it by about 20 bytes at a time, recompile and test the program, again and again until something fails. Then make the stack size a couple dozen bytes larger than the smallest size that reliably worked during testing...just in case.</p>
<p>The code used to create a task object looks like the following: </p><div class="fragment"><div class="line"><span class="comment">// Create an example task. It runs at priority 2 and has a 200 byte stack</span></div><div class="line">TaskExample* my_example_task </div><div class="line">    = <span class="keyword">new</span> TaskExample (<span class="stringliteral">&quot;Example&quot;</span>, tskIDLE_PRIORITY + 2, 200, &amp;ser_port);</div><div class="line">...</div><div class="line"><span class="comment">// Start up the scheduler, causing all tasks to be run</span></div><div class="line">vTaskStartScheduler ();</div></div><!-- fragment --><p> In this example code, someone must have created the serial port object named <code>ser_port</code> previously; the serial port will be used by the task to print out diagnostic information. If no diagnostic information needs to be printed, the serial port may be left out of the task constructor call or set to <code>NULL</code>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae8e359a838bed17302e4f21146dba612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e359a838bed17302e4f21146dba612">&#9670;&nbsp;</a></span>TaskBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TaskBase::TaskBase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned portBASE_TYPE&#160;</td>
          <td class="paramname"><em>a_priority</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a_stack_size</em> = <code>configMINIMAL_STACK_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemstream.html">emstream</a> *&#160;</td>
          <td class="paramname"><em>p_ser_dev</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor which creates and initializes a task object. </p>
<p>This constructor creates a FreeRTOS task with the given task run function, name, priority, and stack size. It saves a pointers to a serial device to be used for debugging; it also saves a pointer to the previously created task (if any) so that tasks can form a linked list. Any function, such as diagnostic printouts, that is to be performed by all tasks can be done by telling the most recently created task to do it, then have that most recently created task tell the previously created task to do it, and so on.</p>
<p>The odd parameter with the <code>reinterpret_cast</code> directive is a pointer to the FreeRTOS task run function. This pointer, which is supplied to FreeRTOS as a pointer to a function that takes one void pointer parameter and returns nothing, contains a reference to a method belonging to this class called <b><a class="el" href="taskbase_8cpp.html#abeff30a44eadf95fa24c7215cc6d7eae" title="Internal use only function which calls the run() method. ">_call_static_run_method()</a></b>. FreeRTOS will then call <b><a class="el" href="taskbase_8cpp.html#abeff30a44eadf95fa24c7215cc6d7eae" title="Internal use only function which calls the run() method. ">_call_static_run_method()</a></b> which is a regular C (not C++) function that is given a pointer to the task object which the user has created. <b><a class="el" href="taskbase_8cpp.html#abeff30a44eadf95fa24c7215cc6d7eae" title="Internal use only function which calls the run() method. ">_call_static_run_method()</a></b>, being a member of this class, then calls the user's <b><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a></b> method using the fancy virtual method function finding tricks that it can use because it is a C++ method rather than a plain old C function. All this C++ and virtual method fanciness only has to take place once as the scheduler is starting up, so it doesn't slow real-time operation down. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_name</td><td>A character string which will be the name of this task </td></tr>
    <tr><td class="paramname">a_priority</td><td>The priority at which this task will initially run (default: 0) </td></tr>
    <tr><td class="paramname">a_stack_size</td><td>The size of this task's stack in bytes (default: <code>configMINIMAL_STACK_SIZE</code>) </td></tr>
    <tr><td class="paramname">p_ser_dev</td><td>Pointer to a serial device (port, radio, SD card, etc.) which can be used by this task to communicate (default: NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9884c542600faa2f90da35c832fea87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9884c542600faa2f90da35c832fea87a">&#9670;&nbsp;</a></span>_call_users_run_method()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::_call_users_run_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_task_base.html">TaskBase</a> *&#160;</td>
          <td class="paramname"><em>p_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only function which calls the <code><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a></code> method. </p>
<p><b>This method never needs to be called by user-written code.</b> This <code>static</code> method calls the user-written <code><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a></code> method when it has been called by <code><a class="el" href="taskbase_8cpp.html#abeff30a44eadf95fa24c7215cc6d7eae" title="Internal use only function which calls the run() method. ">_call_static_run_method()</a></code>. The function <code><a class="el" href="taskbase_8cpp.html#abeff30a44eadf95fa24c7215cc6d7eae" title="Internal use only function which calls the run() method. ">_call_static_run_method()</a></code> function was, in turn, called by FreeRTOS; it is the C (not C++) function which was registered with the scheduler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_task</td><td>A pointer to the task (this task) whose run method is to be called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06d9c962cc578a84a69ca637f6d5adef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d9c962cc578a84a69ca637f6d5adef">&#9670;&nbsp;</a></span>delay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::delay </td>
          <td>(</td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop running the task for the given number of RTOS ticks. </p>
<p>This method causes the task to stop running for the given number of RTOS ticks from the time it is called. This method should <b>not</b> be used to make a task run at regular intervals, because the time between when the previous delay ended and and when <code><a class="el" href="class_task_base.html#a06d9c962cc578a84a69ca637f6d5adef" title="Stop running the task for the given number of RTOS ticks. ">delay()</a></code> is called subsequently can vary, leading to the accumulation of errors in timing. For periodic runs of code in a task, see <code><a class="el" href="class_task_base.html#adc48db72592a8b34ca1235e1d18604cc" title="Stop the task from running for a precise time interval. ">delay_from_for()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The amount of time, as a number of timer ticks, this task should wait until next running </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc48db72592a8b34ca1235e1d18604cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc48db72592a8b34ca1235e1d18604cc">&#9670;&nbsp;</a></span>delay_from_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::delay_from_for </td>
          <td>(</td>
          <td class="paramtype">TickType_t &amp;&#160;</td>
          <td class="paramname"><em>from_ticks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>for_how_long</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the task from running for a precise time interval. </p>
<p>This method causes the task to stop running from a given time for a specified duration. The start time and duration are given in units of RTOS timer ticks. This method can be used to implement a task that regularly wakes up and performs some action, like a clown waking up to terrify children. Because the time at which each awakening takes place is recorded, this method won't accumulate errors as it is repeatedly invoked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_ticks</td><td>The beginning time of the duration to delay. It is usually set equal to the time at which the previous delay began so as to get precise, regular timing </td></tr>
    <tr><td class="paramname">for_how_long</td><td>The duration of the delay interval in RTOS ticks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31b1c01059c7ec4bfe60fc8332759551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b1c01059c7ec4bfe60fc8332759551">&#9670;&nbsp;</a></span>delay_from_for_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::delay_from_for_ms </td>
          <td>(</td>
          <td class="paramtype">TickType_t &amp;&#160;</td>
          <td class="paramname"><em>from_ticks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>millisec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the task from running for a precise number of milliseconds. </p>
<p>This method causes the task to delay from a given time for a specified duration in milliseconds. This is usually done to make a task that runs code at a fairly precise and regular interval. The start time is given in units of RTOS timer ticks; although ticks might not equal milliseconds, the user need not care, just store the value in a variable of type <code>TickType_t</code>. The delay duration is given in milliseconds. An example of how this method is used follows: </p><div class="fragment"><div class="line"><span class="comment">// Make a variable which will hold tick counts and initialize it</span></div><div class="line">TickType_t previousTicks = xTaskGetTickCount ();</div><div class="line">...</div><div class="line">for (;;)                   <span class="comment">// The task loop</span></div><div class="line">{</div><div class="line">    ...                    <span class="comment">// User code to run every 10 ms</span></div><div class="line">    ...</div><div class="line">    <a class="code" href="class_task_base.html#a31b1c01059c7ec4bfe60fc8332759551">delay_from_for_ms</a> (previousTicks, 10);</div><div class="line">}</div></div><!-- fragment --><p> <b>Warning:</b> In order for this function to provide accurate timing, the RTOS tick rate (set in <code><a class="el" href="_free_r_t_o_s_config_8h_source.html">FreeRTOSConfig.h</a></code> ) must be set to a rate such that RTOS ticks occur at the desired time interval. For example, if a task must awaken once per millisecond, ticks at 1 ms or 0.5 ms are OK, but ticks every 2 ms or 0.7 ms will not allow pricise timing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_ticks</td><td>The beginning time of the duration to delay. It is usually set equal to the end time of the previous delay so as to get precise, regular timing </td></tr>
    <tr><td class="paramname">millisec</td><td>The duration of the delay interval in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a7e9bc3d85a0e71462002b85402d995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7e9bc3d85a0e71462002b85402d995">&#9670;&nbsp;</a></span>delay_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::delay_ms </td>
          <td>(</td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>duration_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the task for approximately the given number of milliseconds. </p>
<p>This method causes the task to stop running for approximately the given number of milliseconds. This method should <b>not</b> be used to make a task run at regular intervals, because the time between when the previous delay ended and and when <code><a class="el" href="class_task_base.html#a6a7e9bc3d85a0e71462002b85402d995" title="Stop the task for approximately the given number of milliseconds. ">delay_ms()</a></code> is called subsequently can vary, leading to the accumulation of errors in timing. For periodic runs of code in a task, see <code><a class="el" href="class_task_base.html#a31b1c01059c7ec4bfe60fc8332759551" title="Stop the task from running for a precise number of milliseconds. ">delay_from_for_ms()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration_ms</td><td>The duration for the task to stop in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e228e424048594a935cd31ae9e0eeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e228e424048594a935cd31ae9e0eeb3">&#9670;&nbsp;</a></span>dump_stack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::dump_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemstream.html">emstream</a> *&#160;</td>
          <td class="paramname"><em>p_ser_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a display of this task's stack space. </p>
<p>This method prints a hexadecimal and text format dump of the stack's contents for debugging and instructional purposes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_ser_dev</td><td>The serial device to which the stack will be printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5842a497b5a274e6a40fae18bff03a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5842a497b5a274e6a40fae18bff03a9f">&#9670;&nbsp;</a></span>emergency_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::emergency_reset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an error message if possible and reset the processor. </p>
<p>This method prints an error message (if there is a valid serial device pointer available) and resets the processor. It should only be used in cases of things going seriously to heck. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>A message to print before restarting; <code>endl</code> is appended to it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2113de68c720fcf8b643b11a43b84ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2113de68c720fcf8b643b11a43b84ab7">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TaskHandle_t TaskBase::get_handle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a handle to the FreeRTOS task wrapped by this task object. </p>
<p>This method returns the handle of the FreeRTOS task which is inside this object. Advanced users might want to use it to access task manipulation functions that aren't in this wrapper class or for other creative hacking. </p><dl class="section return"><dt>Returns</dt><dd>The handle of the FreeRTOS task which is wrapped in this handy C++ class </dd></dl>

</div>
</div>
<a id="a6d6efe1287e0d4b73064af05626e48d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6efe1287e0d4b73064af05626e48d2">&#9670;&nbsp;</a></span>get_last_created_task_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_task_base.html">TaskBase</a>* TaskBase::get_last_created_task_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the most recently created task. </p>
<p>This method returns a pointer to the most recently created task. This pointer is the head of a linked list of tasks; the list is maintained by the task objects themselves. This pointer to the most recently created task is used to begin traversing the list of all tasks when some action needs to be taken by all the tasks. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the most recently created task </dd></dl>

</div>
</div>
<a id="adbc9cc6b14c5396c38457edc9c9bc215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc9cc6b14c5396c38457edc9c9bc215">&#9670;&nbsp;</a></span>get_loop_runs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TaskBase::get_loop_runs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method allows descendent classes to find out how many times the <code>loop()</code> method has run. </p><dl class="section return"><dt>Returns</dt><dd>The number of times the loop has been run </dd></dl>

</div>
</div>
<a id="a69b0a4031cf715d9d3a6ecd3b29f5cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b0a4031cf715d9d3a6ecd3b29f5cbe">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* TaskBase::get_name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to this task's name. </p>
<p>This method returns a pointer to the task's name, which resides in a null terminated character array belonging to the task. Because the pointer is of type <code>const</code> <code>char</code>, that pointer cannot be used to change the task's name (unless typecasting tricks are used in a way that is poor programming practice). </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the task's name </dd></dl>

</div>
</div>
<a id="a1f26fc9564898da36d2355095c204340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f26fc9564898da36d2355095c204340">&#9670;&nbsp;</a></span>get_priority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">portBASE_TYPE TaskBase::get_priority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task's current priority. </p>
<dl class="section return"><dt>Returns</dt><dd>The priority at which the task is currently running </dd></dl>

</div>
</div>
<a id="ae4f412b0911d4cf84dad9169a10c46e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f412b0911d4cf84dad9169a10c46e0">&#9670;&nbsp;</a></span>get_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t TaskBase::get_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current state in which this task's state machine is. </p>
<p>This method returns the transition logic state in which the task is at the current time. This is the value of the variable <code>state</code> which is manipulated by the user within the <code><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a></code> method to cause state transitions. </p><dl class="section return"><dt>Returns</dt><dd>The current state </dd></dl>

</div>
</div>
<a id="aea05d3d35f6cbda823ed4812b0951944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea05d3d35f6cbda823ed4812b0951944">&#9670;&nbsp;</a></span>get_tick_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TickType_t TaskBase::get_tick_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out how many RTOS ticks since the scheduler was started. </p>
<p>This method returns the number of RTOS ticks from the time the scheduler was started up until the time the method is called. By using the number of RTOS ticks per second, one can determine real time approximately. The precision of this method of timekeeping isn't really good because RTOS ticks typically only occur every millisecond or so; for high precision timing one needs to use a timer/counter running much faster than that. </p><dl class="section return"><dt>Returns</dt><dd>The number of RTOS ticks which have happened since RTOS startup </dd></dl>

</div>
</div>
<a id="a4d0769068c3095d76752e0a00963d8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0769068c3095d76752e0a00963d8b8">&#9670;&nbsp;</a></span>get_tick_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float TaskBase::get_tick_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an approximate measurement of time from the tick count. </p>
<p>This method gets the tick count, which is the number of RTOS ticks which have occurred since the RTOS was started up, and converts the value from ticks into seconds. The resolution of this time measurement is only as good as the resolution of the RTOS tick rate, typically around a millisecond or so. </p><dl class="section return"><dt>Returns</dt><dd>The approximate real time </dd></dl>

</div>
</div>
<a id="aa3979e41ecb8f646f12d4283d87f93df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3979e41ecb8f646f12d4283d87f93df">&#9670;&nbsp;</a></span>get_total_stack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t TaskBase::get_total_stack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total stack size for this task. </p>
<p>This method returns the task's total stack size, which was set in the constructor call. </p><dl class="section return"><dt>Returns</dt><dd>The task's total stack size in bytes </dd></dl>

</div>
</div>
<a id="a822796dba0ef4d457608363507d65f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822796dba0ef4d457608363507d65f5a">&#9670;&nbsp;</a></span>heap_left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t TaskBase::heap_left </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of unused bytes in the heap. </p>
<p>This method returns the number of bytes left to be used in the heap. This means that the number returned is how many bytes available for allocation. </p><dl class="section return"><dt>Returns</dt><dd>The approximate number of bytes left for use in the heap </dd></dl>

</div>
</div>
<a id="a0dbf9678429543f33c9c8f82511a3887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbf9678429543f33c9c8f82511a3887">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TaskBase::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a task is ready to run. </p>
<p>This overloaded operator allows one to check if the task is valid and ready to run. It looks at the task's handle, which is nonzero if the task has been successfully created and hasn't been stopped. </p><dl class="section return"><dt>Returns</dt><dd>True if the task has a valid RTOS task handle and false if not </dd></dl>

</div>
</div>
<a id="a441138caa57e35f58f31dc4d960580d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441138caa57e35f58f31dc4d960580d9">&#9670;&nbsp;</a></span>print_stack_in_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::print_stack_in_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemstream.html">emstream</a> *&#160;</td>
          <td class="paramname"><em>p_ser_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a stack dump within a dump of all tasks' stacks. </p>
<p>Show one task's stack as a hex dump.</p>
<p>This method prints a stack dump, then asks the next task in the linked list of tasks to do the same, and so on and so on, so all the tasks have shown their stack space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_ser_dev</td><td>A pointer to a serial device on which the stack is shown</td></tr>
  </table>
  </dd>
</dl>
<p>This method displays the task's stack in the format of a hex dump, with the data in the stack shown as a bunch of hexadecimal numbers as well as text. Then it finds the previously created task and asks that task to print its stack as well; when the process is done all tasks (except the idle task) will have printed their stacks. The idle task's stack is printed separately afterwards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_ser_dev</td><td>The serial device to which each task prints its stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea504e1e3d38a7e8e8c65c4284d4a560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea504e1e3d38a7e8e8c65c4284d4a560">&#9670;&nbsp;</a></span>print_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::print_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemstream.html">emstream</a> &amp;&#160;</td>
          <td class="paramname"><em>ser_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method prints information about the task. It is called by the overloaded "&lt;&lt;" operator which is used by the task to print itself when asked to. This function is declared virtual so that descendents can override it to print additional information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ser_dev</td><td>A reference to the serial device to which to print the task status </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classtask__sink.html#a16c0c8249299c81490190d0a2a13f7ee">task_sink</a>.</p>

</div>
</div>
<a id="a58bd479a964b4c98da9f8f1a6b08efd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bd479a964b4c98da9f8f1a6b08efd7">&#9670;&nbsp;</a></span>print_status_in_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::print_status_in_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemstream.html">emstream</a> *&#160;</td>
          <td class="paramname"><em>ser_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method prints task status information, then asks the next task in the list of tasks to do so. The list is kept by the tasks, each having a pointer to another. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ser_device</td><td>The serial device to which each task prints its status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcf6036ad9c860051ccf392ba5e7dbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf6036ad9c860051ccf392ba5e7dbbc">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TaskBase::run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run method which holds the user's task code. </p>
<p>This is the method in which the task runs the user's task code. The base class's <code><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a></code> method contains no code, and an object of class <code><a class="el" href="class_task_base.html" title="Base class for implementations of tasks in task/state based programs. ">TaskBase</a></code> cannot be instantiated. The user's code for each task goes in the <code><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a></code> method for each of the user's task classes, each task class being descended from <code><a class="el" href="class_task_base.html" title="Base class for implementations of tasks in task/state based programs. ">TaskBase</a></code>. Often the user's <code><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a></code> method contains a finite state machine; the variable <code>state</code> is provided so that the state machine's operation can be monitored by the parent class to help with debugging.</p>
<p>Because this code is expected to run in a preemptive multitasking environment, the run method should usually contain an infinite loop. An exception is when tasks are being dynamically created and deleted; in this case, one can program a run method which exits, and after exiting a task will be deleted. If tasks are not being deleted, exiting a run method just causes the task to hang in an indefinite loop of repeated delays. Note that a finite state machine pretty much replaces the functionality of tasks which are dynamically created and deleted, except that memory is not recovered when the state machine transitions from one state to another. </p>

<p>Implemented in <a class="el" href="class_d_c_c.html#ade4c1e232d4c2e5de99f5b6c3730104a">DCC</a>, <a class="el" href="class_flip___flap.html#af2c31e47b88414dffa7e96bc6be08a9d">Flip_Flap</a>, <a class="el" href="classtask__source.html#a927a4597966476a7616d4d4120b9c43d">task_source</a>, <a class="el" href="classtask__user.html#adca6429d57be25e8d411414fc8ad75af">task_user</a>, <a class="el" href="classtask__user.html#adca6429d57be25e8d411414fc8ad75af">task_user</a>, <a class="el" href="classtask__sink.html#a90497d9f3e918301d3643181e6e8a42d">task_sink</a>, and <a class="el" href="classtask__multi.html#a66f62aa64889850eca87e1504c604fc8">task_multi</a>.</p>

</div>
</div>
<a id="a1a6f54b0b07cf27d5764c4dca5ec5fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6f54b0b07cf27d5764c4dca5ec5fcf">&#9670;&nbsp;</a></span>set_priority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::set_priority </td>
          <td>(</td>
          <td class="paramtype">portBASE_TYPE&#160;</td>
          <td class="paramname"><em>new_priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this task's priority to a new value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_priority</td><td>The new priority to set for this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad088ca82db29301b019b1efde85156be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad088ca82db29301b019b1efde85156be">&#9670;&nbsp;</a></span>set_serial_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::set_serial_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemstream.html">emstream</a> *&#160;</td>
          <td class="paramname"><em>p_new_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the task's serial device pointer. </p>
<p>This method sets the task's serial device pointer to the given address. Changing this serial device pointer means that debugging output will be directed to the given device. This can be helpful if task transitions or other debugging information should be shown on a serial console as the task is being created but logged somewhere else when the task is running. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_new_dev</td><td>A pointer to the serial device on which debugging information will be printed in the near future </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af70bf7c9cb6dfccdb1dbf41b7c6d2ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70bf7c9cb6dfccdb1dbf41b7c6d2ecf">&#9670;&nbsp;</a></span>transition_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::transition_to </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>new_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause this task to transition to another state. </p>
<p>This method is called within <code><a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a></code> to cause a state transition. It changes the variable <code>state</code>, and if transition logging is enabled, it logs the transition to help with debugging. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_state</td><td>The state to which this task will transition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e1cc480afef3708598b6b217b281a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1cc480afef3708598b6b217b281a7b">&#9670;&nbsp;</a></span>unset_serial_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::unset_serial_device </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn off serial logging by un-setting the task's serial pointer. </p>
<p>This method un-sets the task's serial device pointer. Doing so prevents serial debugging output from being sent or logged in the future unless <code><a class="el" href="class_task_base.html#ad088ca82db29301b019b1efde85156be" title="Set the task&#39;s serial device pointer. ">set_serial_device()</a></code> is called to set the serial device pointer to a serial device. </p>

</div>
</div>
<a id="a4e9fe49dbbf245e182abf6d17c9bd3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9fe49dbbf245e182abf6d17c9bd3df">&#9670;&nbsp;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskBase::yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The task gives control to the RTOS immediately. </p>
<p>This method causes the task in which it's called to yield, giving control of the CPU back to the RTOS, immediately. The RTOS will then decide which task should run; if another task of higher priority wants to run, that task will take over. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5299f7fa222eb0ddac3b77e667170fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5299f7fa222eb0ddac3b77e667170fd7">&#9670;&nbsp;</a></span>p_serial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemstream.html">emstream</a>* TaskBase::p_serial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This pointer can point to a serial output device or port which will be used for various diagnostic printouts or logging. </p>

</div>
</div>
<a id="a4f8adbe534975ada5ffb46fa403ef07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8adbe534975ada5ffb46fa403ef07f">&#9670;&nbsp;</a></span>prev_task_pointer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_task_base.html">TaskBase</a>* TaskBase::prev_task_pointer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a pointer to the previously created task. The pointer will be used to implement a linked list of tasks through which one can traverse. </p>

</div>
</div>
<a id="a9736ccdb46487c91c49bdbf2c24b52d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9736ccdb46487c91c49bdbf2c24b52d3">&#9670;&nbsp;</a></span>previous_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t TaskBase::previous_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This variable keeps track of the previous (before <a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a> runs) value of the state so that transitions can be conveniently detected. </p>

</div>
</div>
<a id="ab5503939e17359f0f3f9249f622df389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5503939e17359f0f3f9249f622df389">&#9670;&nbsp;</a></span>runs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TaskBase::runs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This variable keeps track of how many times the task has run through its loop. In order for it to work, the user must put a line of code that increments this variable, as in <code>runs++</code>; somewhere in the task loop. </p>

</div>
</div>
<a id="aab6866bbd5d036810829ccc7cd3ab0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6866bbd5d036810829ccc7cd3ab0e8">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t TaskBase::state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the state in which the finite state machine of the task is. This variable should be used inside <a class="el" href="class_task_base.html#adcf6036ad9c860051ccf392ba5e7dbbc" title="Run method which holds the user&#39;s task code. ">run()</a> to implement the state machine so that state transitions can be tracked, if needed, by this parent class. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/frtcpp/<a class="el" href="taskbase_8h_source.html">taskbase.h</a></li>
<li>lib/frtcpp/<a class="el" href="taskbase_8cpp.html">taskbase.cpp</a></li>
<li>lib/frtcpp/<a class="el" href="taskbase__stackprt_8cpp.html">taskbase_stackprt.cpp</a></li>
<li>lib/frtcpp/<a class="el" href="taskbase__status_8cpp.html">taskbase_status.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
