<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HOB_DCC: i2c_master Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HOBPoster.2018.12.07.2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HOB_DCC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classi2c__master-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">i2c_master Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver class for an I2C (also known as TWI) bus on an AVR processor.  
 <a href="classi2c__master.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="i2c__master_8h_source.html">i2c_master.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a843928a7894ad896d1feace7fe734ad1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#a843928a7894ad896d1feace7fe734ad1">i2c_master</a> (<a class="el" href="classemstream.html">emstream</a> *=NULL)</td></tr>
<tr class="memdesc:a843928a7894ad896d1feace7fe734ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor creates an I2C driver object.  <a href="#a843928a7894ad896d1feace7fe734ad1">More...</a><br /></td></tr>
<tr class="separator:a843928a7894ad896d1feace7fe734ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69a2ec3ea33a2add78dcc07e7adce00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#ad69a2ec3ea33a2add78dcc07e7adce00">start</a> (void)</td></tr>
<tr class="memdesc:ad69a2ec3ea33a2add78dcc07e7adce00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a start condition on the I2C bus.  <a href="#ad69a2ec3ea33a2add78dcc07e7adce00">More...</a><br /></td></tr>
<tr class="separator:ad69a2ec3ea33a2add78dcc07e7adce00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d66784592f1e026dc42b29f21cdb64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#a96d66784592f1e026dc42b29f21cdb64">restart</a> (void)</td></tr>
<tr class="memdesc:a96d66784592f1e026dc42b29f21cdb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a repeated start condition on the I2C bus.  <a href="#a96d66784592f1e026dc42b29f21cdb64">More...</a><br /></td></tr>
<tr class="separator:a96d66784592f1e026dc42b29f21cdb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3263bda1b2d48a751b9b798559600fe0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#a3263bda1b2d48a751b9b798559600fe0">stop</a> (void)</td></tr>
<tr class="memdesc:a3263bda1b2d48a751b9b798559600fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a stop condition on the I2C bus.  <a href="#a3263bda1b2d48a751b9b798559600fe0">More...</a><br /></td></tr>
<tr class="separator:a3263bda1b2d48a751b9b798559600fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73dfa0d112fb71ed34f42a222c4ecec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#ac73dfa0d112fb71ed34f42a222c4ecec">write</a> (uint8_t address, uint8_t reg, uint8_t data)</td></tr>
<tr class="memdesc:ac73dfa0d112fb71ed34f42a222c4ecec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one byte to a slave device on the I2C bus.  <a href="#ac73dfa0d112fb71ed34f42a222c4ecec">More...</a><br /></td></tr>
<tr class="separator:ac73dfa0d112fb71ed34f42a222c4ecec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fa22c49a5c72c53e8132930cd701e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#af0fa22c49a5c72c53e8132930cd701e5">write</a> (uint8_t address, uint8_t reg, uint8_t *p_buf, uint8_t count)</td></tr>
<tr class="memdesc:af0fa22c49a5c72c53e8132930cd701e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a bunch of bytes to a slave device on the I2C bus.  <a href="#af0fa22c49a5c72c53e8132930cd701e5">More...</a><br /></td></tr>
<tr class="separator:af0fa22c49a5c72c53e8132930cd701e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1513222d835e893e05009bd49038c1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#a3e1513222d835e893e05009bd49038c1">read</a> (uint8_t address, uint8_t reg)</td></tr>
<tr class="memdesc:a3e1513222d835e893e05009bd49038c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one byte from a slave device on the I2C bus.  <a href="#a3e1513222d835e893e05009bd49038c1">More...</a><br /></td></tr>
<tr class="separator:a3e1513222d835e893e05009bd49038c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc041e481c0516a4c0fa7158c4f1fc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#aebc041e481c0516a4c0fa7158c4f1fc0">read</a> (uint8_t address, uint8_t reg, uint8_t *p_buffer, uint8_t count)</td></tr>
<tr class="memdesc:aebc041e481c0516a4c0fa7158c4f1fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from a slave device on the I2C bus.  <a href="#aebc041e481c0516a4c0fa7158c4f1fc0">More...</a><br /></td></tr>
<tr class="separator:aebc041e481c0516a4c0fa7158c4f1fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf14a54e71e000366a963d1180aa9cfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#aaf14a54e71e000366a963d1180aa9cfb">write_byte</a> (uint8_t byte)</td></tr>
<tr class="memdesc:aaf14a54e71e000366a963d1180aa9cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a byte to a device on the I2C bus.  <a href="#aaf14a54e71e000366a963d1180aa9cfb">More...</a><br /></td></tr>
<tr class="separator:aaf14a54e71e000366a963d1180aa9cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec5f20ac4b77ff82811a44d6c9f0273"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#aeec5f20ac4b77ff82811a44d6c9f0273">read_byte</a> (bool ack)</td></tr>
<tr class="memdesc:aeec5f20ac4b77ff82811a44d6c9f0273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a byte from a device on the I2C bus.  <a href="#aeec5f20ac4b77ff82811a44d6c9f0273">More...</a><br /></td></tr>
<tr class="separator:aeec5f20ac4b77ff82811a44d6c9f0273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f502f0e44b3eecea3f9069b5039295"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#a45f502f0e44b3eecea3f9069b5039295">check_SDA</a> (void)</td></tr>
<tr class="memdesc:a45f502f0e44b3eecea3f9069b5039295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status of the SDA line.  <a href="#a45f502f0e44b3eecea3f9069b5039295">More...</a><br /></td></tr>
<tr class="separator:a45f502f0e44b3eecea3f9069b5039295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336d8879f371ebcba91d2a83509d517f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#a336d8879f371ebcba91d2a83509d517f">ping</a> (uint8_t address)</td></tr>
<tr class="memdesc:a336d8879f371ebcba91d2a83509d517f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a device is located at the given address.  <a href="#a336d8879f371ebcba91d2a83509d517f">More...</a><br /></td></tr>
<tr class="separator:a336d8879f371ebcba91d2a83509d517f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec7ac7b06f563c195a13ae51b076b0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#abec7ac7b06f563c195a13ae51b076b0a">scan</a> (<a class="el" href="classemstream.html">emstream</a> *p_ser)</td></tr>
<tr class="memdesc:abec7ac7b06f563c195a13ae51b076b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan the I2C bus, pinging each address, and print the results.  <a href="#abec7ac7b06f563c195a13ae51b076b0a">More...</a><br /></td></tr>
<tr class="separator:abec7ac7b06f563c195a13ae51b076b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9afe624ce1825efb79c147093ad8ad3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#aa9afe624ce1825efb79c147093ad8ad3">take_mutex</a> (void)</td></tr>
<tr class="memdesc:aa9afe624ce1825efb79c147093ad8ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the mutex associated with this I2C bus.  <a href="#aa9afe624ce1825efb79c147093ad8ad3">More...</a><br /></td></tr>
<tr class="separator:aa9afe624ce1825efb79c147093ad8ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ea221508ef4f0310bc61030773bd58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#a49ea221508ef4f0310bc61030773bd58">give_mutex</a> (void)</td></tr>
<tr class="memdesc:a49ea221508ef4f0310bc61030773bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give back the mutex associated with this I2C bus.  <a href="#a49ea221508ef4f0310bc61030773bd58">More...</a><br /></td></tr>
<tr class="separator:a49ea221508ef4f0310bc61030773bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a862f9d4025a9b98dbc6491b3430840a0"><td class="memItemLeft" align="right" valign="top"><a id="a862f9d4025a9b98dbc6491b3430840a0"></a>
<a class="el" href="classemstream.html">emstream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#a862f9d4025a9b98dbc6491b3430840a0">p_serial</a></td></tr>
<tr class="memdesc:a862f9d4025a9b98dbc6491b3430840a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pointer to a serial port object which is used for debugging the code. <br /></td></tr>
<tr class="separator:a862f9d4025a9b98dbc6491b3430840a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b87e4fe5ef8e2fdfbcfec893c885ef"><td class="memItemLeft" align="right" valign="top"><a id="a94b87e4fe5ef8e2fdfbcfec893c885ef"></a>
SemaphoreHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c__master.html#a94b87e4fe5ef8e2fdfbcfec893c885ef">mutex</a></td></tr>
<tr class="memdesc:a94b87e4fe5ef8e2fdfbcfec893c885ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used to prevent simultaneous uses of the I2C port. <br /></td></tr>
<tr class="separator:a94b87e4fe5ef8e2fdfbcfec893c885ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Driver class for an I2C (also known as TWI) bus on an AVR processor. </p>
<p>It encapsulates basic I2C functionality such as the ability to send and receive bytes through the TWI bus. Currently only operation of the AVR as an I2C bus master is supported; this is what's needed for the AVR to interface with most I2C based sensors. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a843928a7894ad896d1feace7fe734ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843928a7894ad896d1feace7fe734ad1">&#9670;&nbsp;</a></span>i2c_master()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_master::i2c_master </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemstream.html">emstream</a> *&#160;</td>
          <td class="paramname"><em>p_debug_port</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This constructor creates an I2C driver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_debug_port</td><td>A serial port, often RS-232, for debugging text (default: <code>NULL</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a45f502f0e44b3eecea3f9069b5039295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f502f0e44b3eecea3f9069b5039295">&#9670;&nbsp;</a></span>check_SDA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_master::check_SDA </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the status of the SDA line. </p>
<p>This method just finds whether the SDA line is currently high or low. This method may be needed when some sensors may need to wait for the SDA line to be directly manipulated by the sensor to indicate that data is available. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the SDA line is high, <code>false</code> if it is low </dd></dl>

</div>
</div>
<a id="a49ea221508ef4f0310bc61030773bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ea221508ef4f0310bc61030773bd58">&#9670;&nbsp;</a></span>give_mutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master::give_mutex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give back the mutex associated with this I2C bus. </p>
<p>This method gives the mutex which controls access to this I2C bus. It's a complement for the <code><a class="el" href="classi2c__master.html#aa9afe624ce1825efb79c147093ad8ad3" title="Take the mutex associated with this I2C bus. ">take_mutex()</a></code> method. </p>

</div>
</div>
<a id="a336d8879f371ebcba91d2a83509d517f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336d8879f371ebcba91d2a83509d517f">&#9670;&nbsp;</a></span>ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_master::ping </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a device is located at the given address. </p>
<p>This method causes an I2C start, then sends the given address and checks for an acknowledgement. After that, it just sends a stop condition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The I2C address for the device. The address should already have been shifted so that it fills the 7 <b>most</b> significant bits of the byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a device acknowledged the given address, <code>false</code> if not </dd></dl>

</div>
</div>
<a id="a3e1513222d835e893e05009bd49038c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1513222d835e893e05009bd49038c1">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t i2c_master::read </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one byte from a slave device on the I2C bus. </p>
<p>This method reads a single byte from the device on the I2C bus at the given address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The I2C address for the device. The address must already have been shifted so that it fills the 7 <b>most</b> significant bits of the byte. </td></tr>
    <tr><td class="paramname">reg</td><td>The register address within the device from which to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte which was read from the device </dd></dl>

</div>
</div>
<a id="aebc041e481c0516a4c0fa7158c4f1fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc041e481c0516a4c0fa7158c4f1fc0">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_master::read </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from a slave device on the I2C bus. </p>
<p>This method reads multiple bytes from the device on the I2C bus at the given address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The I2C address for the device. The address should already have been shifted so that it fills the 7 <b>most</b> significant bits of the byte. </td></tr>
    <tr><td class="paramname">reg</td><td>The register address within the device from which to read </td></tr>
    <tr><td class="paramname">p_buffer</td><td>A pointer to a buffer in which the received bytes will be stored </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to read from the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a problem occurred during reading, <code>false</code> if things went OK </dd></dl>

</div>
</div>
<a id="aeec5f20ac4b77ff82811a44d6c9f0273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec5f20ac4b77ff82811a44d6c9f0273">&#9670;&nbsp;</a></span>read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t i2c_master::read_byte </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a byte from a device on the I2C bus. </p>
<p>This method receives a byte from the I2C bus. Other code must have already run the <code><a class="el" href="classi2c__master.html#ad69a2ec3ea33a2add78dcc07e7adce00" title="Cause a start condition on the I2C bus. ">start()</a></code> command and sent and address byte which got the other device's attention. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td><code>true</code> if we are to end our data request with ACK, telling the slave that we want more data after this; false if we end our data request with NACK, telling the slave that we don't want more data after this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte which was received from the remote device or <code>0xFF</code> for an error </dd></dl>

</div>
</div>
<a id="a96d66784592f1e026dc42b29f21cdb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d66784592f1e026dc42b29f21cdb64">&#9670;&nbsp;</a></span>restart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_master::restart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause a repeated start condition on the I2C bus. </p>
<p>This method causes a repeated start condition on the I2C bus. This is similar to a regular start condition, except that it occurs during an already running conversation, and a different return code is expected if things go as they should. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if there was an error, <code>false</code> if the I2C restart was successful </dd></dl>

</div>
</div>
<a id="abec7ac7b06f563c195a13ae51b076b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec7ac7b06f563c195a13ae51b076b0a">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master::scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemstream.html">emstream</a> *&#160;</td>
          <td class="paramname"><em>p_ser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan the I2C bus, pinging each address, and print the results. </p>
<p>This handy dandy utility function scans each address on the I2C bus and prints a display showing the addresses at which devices responded to a "ping" with acknowledgement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_ser</td><td>A pointer to a serial device on which the scan results are printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad69a2ec3ea33a2add78dcc07e7adce00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69a2ec3ea33a2add78dcc07e7adce00">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_master::start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause a start condition on the I2C bus. </p>
<p>This method causes a start condition on the I2C bus. In hardware, a start condition means that the SDA line is dropped while the SCL line stays high. This gets the attention of all the other devices on the bus so that they will listen for their addresses. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if there was an error, <code>false</code> if the I2C start was successful </dd></dl>

</div>
</div>
<a id="a3263bda1b2d48a751b9b798559600fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3263bda1b2d48a751b9b798559600fe0">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_master::stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cause a stop condition on the I2C bus. </p>
<p>This method causes a stop condition on the I2C bus. It's inline because causing a stop condition is a one-liner (in C++ and even in assembly). </p><dl class="section return"><dt>Returns</dt><dd><code>false</code> meaning OK because there's no test to show an error </dd></dl>

</div>
</div>
<a id="aa9afe624ce1825efb79c147093ad8ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9afe624ce1825efb79c147093ad8ad3">&#9670;&nbsp;</a></span>take_mutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master::take_mutex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the mutex associated with this I2C bus. </p>
<p>This method takes the mutex which controls access to this I2C bus. The mutex is automatically taken by the <code><a class="el" href="classi2c__master.html#a3e1513222d835e893e05009bd49038c1" title="Read one byte from a slave device on the I2C bus. ">read()</a></code> and <code><a class="el" href="classi2c__master.html#ac73dfa0d112fb71ed34f42a222c4ecec" title="Write one byte to a slave device on the I2C bus. ">write()</a></code> commands, but when a device driver needs to use the <code><a class="el" href="classi2c__master.html#aeec5f20ac4b77ff82811a44d6c9f0273" title="Receive a byte from a device on the I2C bus. ">read_byte()</a></code> and <code><a class="el" href="classi2c__master.html#aaf14a54e71e000366a963d1180aa9cfb" title="Send a byte to a device on the I2C bus. ">write_byte()</a></code> commands directly, that driver needs to handle the mutex with this command and the <code><a class="el" href="classi2c__master.html#a49ea221508ef4f0310bc61030773bd58" title="Give back the mutex associated with this I2C bus. ">give_mutex()</a></code> command. </p>

</div>
</div>
<a id="ac73dfa0d112fb71ed34f42a222c4ecec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73dfa0d112fb71ed34f42a222c4ecec">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_master::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one byte to a slave device on the I2C bus. </p>
<p>This method writes a single byte to the device on the I2C bus at the given address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The I2C address for the device. The address should already have been shifted so that it fills the 7 <b>most</b> significant bits of the byte. </td></tr>
    <tr><td class="paramname">reg</td><td>The register address within the device to which to write </td></tr>
    <tr><td class="paramname">data</td><td>The byte of data to be written to the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there were problems or <code>false</code> if everything worked OK </dd></dl>

</div>
</div>
<a id="af0fa22c49a5c72c53e8132930cd701e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fa22c49a5c72c53e8132930cd701e5">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_master::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a bunch of bytes to a slave device on the I2C bus. </p>
<p>This method writes a number of bytes to the device on the I2C bus at the given address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The I2C address for the device. The address should already have been shifted so that it fills the 7 <b>most</b> significant bits of the byte. </td></tr>
    <tr><td class="paramname">reg</td><td>The register address within the device to which to write </td></tr>
    <tr><td class="paramname">p_buf</td><td>Pointer to a memory address at which is found the bytes of data to be written to the device </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to be written from the buffer to the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there were problems or <code>false</code> if everything worked OK </dd></dl>

</div>
</div>
<a id="aaf14a54e71e000366a963d1180aa9cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf14a54e71e000366a963d1180aa9cfb">&#9670;&nbsp;</a></span>write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_master::write_byte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a byte to a device on the I2C bus. </p>
<p>This method performs an I2C send to transfer a byte to a remote device. The expected response code varies depending on what is being sent at what time; some examples of expected responses are as follows:</p><ul>
<li><code>0x18</code> - When one has sent SLA+W, a slave address for a write command, and a good ACK has been received</li>
<li><code>0x40</code> - When one has sent SLA+R, a slave address for a read command, and a good ACK has been received</li>
<li><code>0x28</code> - When one has transmitted a data byte and received a good ACK <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte</td><td>The byte which is being sent to the remote device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an acknowledge bit was detected, <code>false</code> if none was seen </dd></dl>
</li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/sensors/<a class="el" href="i2c__master_8h_source.html">i2c_master.h</a></li>
<li>lib/sensors/<a class="el" href="i2c__master_8cpp.html">i2c_master.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
